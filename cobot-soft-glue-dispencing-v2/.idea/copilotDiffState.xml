<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pl_gui/contour_editor/PointManagerWidget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/contour_editor/PointManagerWidget.py" />
              <option name="originalContent" value="import os&#10;&#10;from PyQt6.QtCore import Qt, QPointF, QSize&#10;from PyQt6.QtGui import QIcon, QColor&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem,&#10;    QComboBox, QPushButton, QApplication, QHBoxLayout, QSizePolicy&#10;)&#10;from functools import partial&#10;from PyQt6.QtGui import QIcon, QFont&#10;&#10;from pl_gui.contour_editor.SegmentSettingsWidget import SegmentSettingsWidget&#10;from API.shared.settings.conreateSettings.enums.GlueSettingKey import GlueSettingKey&#10;from API.shared.settings.conreateSettings.enums.RobotSettingKey import RobotSettingKey&#10;from pl_gui.specific.enums.GlueType import GlueType&#10;from pl_gui.contour_editor.LayerButtonsWidget import LayerButtonsWidget&#10;from pl_gui.contour_editor.SegmentButtonsAndComboWidget import SegmentButtonsAndComboWidget&#10;from PyQt6.QtWidgets import QApplication&#10;import sys&#10;&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR,&quot;dropdown_open.png&quot;)&#10;&#10;class PointManagerWidget(QWidget):&#10;    def __init__(self, contour_editor=None):&#10;        super().__init__()&#10;        self.setLayout(QVBoxLayout())&#10;        self.layout().setContentsMargins(8, 8, 8, 8)&#10;        self.layout().setSpacing(4)&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QWidget {&#10;                font-size: 18px;&#10;            }&#10;            QPushButton {&#10;                min-width: 64px;&#10;                min-height: 64px;&#10;                padding: 10px;&#10;                border: None;&#10;            }&#10;            QComboBox {&#10;                min-height: 40px;&#10;                font-size: 18px;&#10;            }&#10;            QTreeWidget {&#10;                outline: none;&#10;                border: 1px solid #ccc;&#10;                background-color: white;&#10;            }&#10;            QTreeWidget::item {&#10;                height: 52px;&#10;                padding: 2px;&#10;            }&#10;            QTreeWidget::item:selected {&#10;                background-color: #e6f3ff;&#10;                border: 1px solid #007acc;&#10;            }&#10;            QTreeWidget::item:hover {&#10;                background-color: #f0f8ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.layout().setAlignment(Qt.AlignmentFlag.AlignTop)&#10;&#10;        self.contour_editor = contour_editor&#10;        if self.contour_editor:&#10;            self.contour_editor.pointsUpdated.connect(self.refresh_points)&#10;&#10;        self._setup_tree_widget()&#10;        self.layout().addWidget(self.tree)&#10;&#10;        self.layers = {}&#10;        self.is_drag_mode = False&#10;&#10;        self.initialize_tree_structure()&#10;&#10;    def _setup_tree_widget(self):&#10;        &quot;&quot;&quot;Initialize and configure the tree widget&quot;&quot;&quot;&#10;        self.tree = QTreeWidget()&#10;        # self.tree.setHeaderLabels([&quot;Layers&quot;, &quot;Controls&quot;])&#10;        self.tree.setHeaderLabels([&quot;&quot;])&#10;        self.tree.setRootIsDecorated(True)&#10;        self.tree.setAlternatingRowColors(True)&#10;        self.tree.setIndentation(20)&#10;&#10;        # Set initial column widths&#10;        self.tree.setColumnWidth(0, 120)&#10;        self.tree.setColumnWidth(1, 320)&#10;&#10;        # Connect signals&#10;        self.tree.itemClicked.connect(self.highlight_selected_point)&#10;        self.tree.itemChanged.connect(self.handle_segment_toggle)&#10;&#10;    def initialize_tree_structure(self):&#10;        &quot;&quot;&quot;Initialize the tree structure with layer items&quot;&quot;&quot;&#10;        self.tree.clear()&#10;        self.layers = {}&#10;&#10;        for name in [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]:&#10;            layer_item = self._create_layer_item(name)&#10;            self.tree.addTopLevelItem(layer_item)&#10;            self.layers[name] = layer_item&#10;&#10;            button_container = self._create_layer_button_container(name, layer_item)&#10;            self.tree.setItemWidget(layer_item, 0, button_container)&#10;&#10;        # Expand all layers by default&#10;        for layer_item in self.layers.values():&#10;            layer_item.setExpanded(True)&#10;&#10;    def _create_layer_item(self, name):&#10;        &quot;&quot;&quot;Create a layer item with proper configuration&quot;&quot;&quot;&#10;        layer_item = QTreeWidgetItem([])&#10;        layer_item.setFlags(layer_item.flags() &amp; ~Qt.ItemFlag.ItemIsUserCheckable)&#10;        layer_item.setFont(0, QFont(&quot;Arial&quot;, 16, QFont.Weight.Bold))&#10;        return layer_item&#10;&#10;    def _create_layer_button_container(self, layer_name, layer_item):&#10;&#10;        is_locked = self.contour_editor.manager.isLayerLocked(layer_name)&#10;&#10;        widget = LayerButtonsWidget(&#10;            layer_name=layer_name,&#10;            layer_item=layer_item,&#10;            on_visibility_toggle=lambda visible: self.set_layer_visibility(layer_name, visible),&#10;            on_add_segment=self._make_add_segment(layer_name, layer_item),&#10;            on_lock_toggle=self._make_layer_lock_toggle(layer_name),&#10;            is_locked=is_locked&#10;        )&#10;        return widget&#10;&#10;    def _make_layer_lock_toggle(self, layer_name):&#10;        def toggle_lock(locked):&#10;            if self.contour_editor:&#10;                self.contour_editor.set_layer_locked(layer_name, locked)&#10;                self.contour_editor.update()&#10;            print(f&quot;[ContourEditor] Set {layer_name} locked = {locked}&quot;)&#10;&#10;        return toggle_lock&#10;&#10;&#10;    def _make_add_segment(self, layer_name, layer_item):&#10;        &quot;&quot;&quot;Create an add segment function&quot;&quot;&quot;&#10;&#10;        def add_segment():&#10;            print(f&quot;Adding new segment to {layer_name}&quot;)&#10;            self.contour_editor.addNewSegment(layer_name)&#10;            self.refresh_points()&#10;&#10;            if layer_item:&#10;                self.tree.expandItem(layer_item)&#10;&#10;            # Force UI refresh&#10;            self.tree.viewport().update()&#10;&#10;        return add_segment&#10;&#10;    def set_layer_visibility(self, layer_name, visible):&#10;        &quot;&quot;&quot;Set the visibility of a layer&quot;&quot;&quot;&#10;        print(f&quot;[ContourEditor] Set {layer_name} visibility to {visible}&quot;)&#10;        self.contour_editor.set_layer_visibility(layer_name, visible)&#10;        self.update()&#10;&#10;    def get_current_selected_layer(self):&#10;        &quot;&quot;&quot;Get the currently selected layer name&quot;&quot;&quot;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            top_item = self.tree.topLevelItem(i)&#10;            if self.tree.currentItem() == top_item or top_item.isSelected():&#10;                return top_item.text(0)&#10;        return &quot;External&quot;&#10;&#10;    def refresh_points(self):&#10;        &quot;&quot;&quot;Refresh the points display in the tree&quot;&quot;&quot;&#10;        self.tree.blockSignals(True)&#10;        try:&#10;            if not self.contour_editor:&#10;                return&#10;&#10;            expanded_paths = self._save_expanded_state()&#10;            selected_path = self._save_selected_path()&#10;            # Remember the active segment index&#10;            active_segment_index = getattr(self.contour_editor.manager, &quot;active_segment_index&quot;, None)&#10;&#10;            self._clear_layer_children()&#10;            self._populate_segments()&#10;&#10;            self._restore_expanded_state(expanded_paths)&#10;            self._restore_selected_path(selected_path)&#10;            # Restore the active segment UI&#10;            if active_segment_index is not None:&#10;                self.set_active_segment_ui(active_segment_index)&#10;        finally:&#10;            self.tree.blockSignals(False)&#10;&#10;    def _save_expanded_state(self):&#10;        &quot;&quot;&quot;Save the current expanded state of tree items&quot;&quot;&quot;&#10;        expanded_paths = set()&#10;&#10;        def record_expansion(item, path=&quot;&quot;):&#10;            if item.isExpanded():&#10;                expanded_paths.add(path)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                record_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            record_expansion(item, item.text(0))&#10;&#10;        return expanded_paths&#10;&#10;    def _save_selected_path(self):&#10;        &quot;&quot;&quot;Save the path to the currently selected item&quot;&quot;&quot;&#10;        selected_item = self.tree.currentItem()&#10;        if not selected_item:&#10;            return None&#10;&#10;        path = []&#10;        node = selected_item&#10;        while node:&#10;            path.insert(0, node.text(0))&#10;            node = node.parent()&#10;        return &quot;/&quot;.join(path)&#10;&#10;    def _clear_layer_children(self):&#10;        &quot;&quot;&quot;Clear all children from layer items&quot;&quot;&quot;&#10;        for layer_item in self.layers.values():&#10;            layer_item.takeChildren()&#10;&#10;    def _populate_segments(self):&#10;        &quot;&quot;&quot;Populate segments in the tree structure&quot;&quot;&quot;&#10;        segments = self.contour_editor.manager.get_segments()&#10;        print(f&quot;Segments: {segments}&quot;)&#10;&#10;        for seg_index, segment in enumerate(segments):&#10;            layer = getattr(segment, &quot;layer&quot;)&#10;            if layer is None:&#10;                continue&#10;&#10;            print(f&quot;Segment {seg_index}: Layer = {layer}&quot;)&#10;            layer_name = layer.name&#10;&#10;            parent_layer = self.layers.get(layer_name)&#10;&#10;            # Create layer dynamically if it doesn't exist&#10;            if not parent_layer:&#10;                print(f&quot;Warning: Layer '{layer_name}' not found, creating it.&quot;)&#10;                parent_layer = self._create_layer_item(layer_name)&#10;                self.layers[layer_name] = parent_layer&#10;                self.tree.addTopLevelItem(parent_layer)&#10;&#10;            # Create segment item&#10;            # seg_item = QTreeWidgetItem([f&quot;S{seg_index}&quot;, &quot;&quot;])&#10;            seg_item = QTreeWidgetItem([&quot;&quot;])&#10;            seg_item.setFlags(seg_item.flags() &amp; ~Qt.ItemFlag.ItemIsEditable)&#10;            seg_item.setFont(0, QFont(&quot;Arial&quot;, 14))&#10;            parent_layer.addChild(seg_item)&#10;            # ✅ Store seg_index in the item&#10;            seg_item.setData(0, Qt.ItemDataRole.UserRole, seg_index)&#10;&#10;            # Create segment control widgets&#10;            seg_container = self._create_segment_container(seg_item, seg_index, segment, layer_name)&#10;            self.tree.setItemWidget(seg_item, 0, seg_container)&#10;&#10;            # Add point children&#10;            self._add_anchor_and_control_points(seg_item, segment)&#10;&#10;        print(&quot;Segments populated.&quot;)&#10;&#10;    def _create_segment_container(self, seg_item, seg_index, segment, layer_name):&#10;        def on_visibility(btn):&#10;            visible = btn.isChecked()&#10;            btn.setIcon(QIcon(HIDE_ICON if visible else SHOW_ICON))&#10;            self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;            self.contour_editor.update()&#10;&#10;        def on_activate():&#10;            self.set_active_segment_ui(seg_index)&#10;&#10;        def on_delete():&#10;            self.delete_segment(seg_index)&#10;&#10;        def on_settings():&#10;            self._on_settings_button_clicked(seg_index)&#10;&#10;        def on_layer_change(new_layer_name):&#10;            self.assign_segment_layer(seg_index, new_layer_name)&#10;&#10;        return SegmentButtonsAndComboWidget(&#10;            seg_index=seg_index,&#10;            segment=segment,&#10;            layer_name=layer_name,&#10;            on_visibility=on_visibility,&#10;            on_activate=on_activate,&#10;            on_delete=on_delete,&#10;            on_settings=on_settings,&#10;            on_layer_change=on_layer_change&#10;        )&#10;&#10;    def _show_settings_dialog(self,seg_index, segment):&#10;        # Prepare input keys for the settings widget&#10;        inputKeys = [key.value for key in GlueSettingKey]&#10;        if GlueSettingKey.GLUE_TYPE.value in inputKeys:&#10;            inputKeys.remove(GlueSettingKey.GLUE_TYPE.value)&#10;&#10;        inputKeys.append(RobotSettingKey.VELOCITY.value)&#10;        inputKeys.append(RobotSettingKey.ACCELERATION.value)&#10;&#10;        comboEnums = [[GlueSettingKey.GLUE_TYPE.value, GlueType]]&#10;&#10;        # Create the settings widget&#10;        from PyQt6.QtWidgets import QDialog, QVBoxLayout&#10;&#10;        dialog = QDialog()&#10;        dialog.setWindowTitle(f&quot;Segment {seg_index} Settings&quot;)&#10;        dialog.setMinimumWidth(400)&#10;        dialog.setMinimumHeight(300)&#10;&#10;        widget = SegmentSettingsWidget(inputKeys + [GlueSettingKey.GLUE_TYPE.value], comboEnums, segment=segment,&#10;                                       parent=dialog)&#10;        layout = QVBoxLayout(dialog)&#10;        layout.addWidget(widget)&#10;        dialog.setLayout(layout)&#10;&#10;        dialog.exec()  # This will keep the dialog open until closed explicitly&#10;&#10;    def _on_settings_button_clicked(self, seg_index):&#10;        segment = self.contour_editor.manager.get_segments()[seg_index]&#10;        layer = getattr(segment, &quot;layer&quot;, None)&#10;        layer_name = layer.name if layer else &quot;Unknown&quot;&#10;        print(f&quot;Settings button clicked for segment {seg_index} (Layer: {layer_name})&quot;)&#10;        self._show_settings_dialog(seg_index,segment)&#10;&#10;&#10;&#10;    def _add_anchor_and_control_points(self, seg_item, segment):&#10;        &quot;&quot;&quot;Add anchor and control points as children of the segment item&quot;&quot;&quot;&#10;        # Add anchor points&#10;        for i, pt in enumerate(segment.points):&#10;            coords = f&quot;({pt.x():.1f}, {pt.y():.1f})&quot; if isinstance(pt, QPointF) else &quot;Invalid&quot;&#10;            pt_item = QTreeWidgetItem([f&quot;P{i}&quot;, coords])&#10;            pt_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            pt_item.setForeground(0, QColor(&quot;#0066cc&quot;))&#10;            seg_item.addChild(pt_item)&#10;&#10;        # Add control points&#10;        for i, ctrl in enumerate(segment.controls):&#10;            coords = f&quot;({ctrl.x():.1f}, {ctrl.y():.1f})&quot; if isinstance(ctrl, QPointF) else &quot;Invalid&quot;&#10;            ctrl_item = QTreeWidgetItem([f&quot;C{i}&quot;, coords])&#10;            ctrl_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            ctrl_item.setForeground(0, QColor(&quot;#cc6600&quot;))&#10;            seg_item.addChild(ctrl_item)&#10;&#10;    def _restore_expanded_state(self, expanded_paths):&#10;        &quot;&quot;&quot;Restore the expanded state of tree items&quot;&quot;&quot;&#10;&#10;        def restore_expansion(item, path=&quot;&quot;):&#10;            if path in expanded_paths:&#10;                item.setExpanded(True)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                restore_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            restore_expansion(item, item.text(0))&#10;&#10;    def _restore_selected_path(self, selected_path):&#10;        &quot;&quot;&quot;Restore the selected item based on saved path&quot;&quot;&quot;&#10;        if not selected_path:&#10;            return&#10;&#10;        def find_item_by_path(root, path_parts):&#10;            if not path_parts:&#10;                return root&#10;            for i in range(root.childCount()):&#10;                child = root.child(i)&#10;                if child.text(0) == path_parts[0]:&#10;                    return find_item_by_path(child, path_parts[1:])&#10;            return None&#10;&#10;        path_parts = selected_path.split(&quot;/&quot;)&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            if item.text(0) == path_parts[0]:&#10;                target = find_item_by_path(item, path_parts[1:])&#10;                if target:&#10;                    self.tree.setCurrentItem(target)&#10;                    break&#10;&#10;    def set_active_segment_ui(self, seg_index):&#10;        &quot;&quot;&quot;Update UI to reflect the active segment&quot;&quot;&quot;&#10;        self.contour_editor.manager.set_active_segment(seg_index)&#10;        print(f&quot;[DEBUG] Set active segment to {seg_index}&quot;)&#10;&#10;        # Update all segment active buttons&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            layer_item = self.tree.topLevelItem(i)&#10;            for j in range(layer_item.childCount()):&#10;                seg_item = layer_item.child(j)&#10;                # Use seg_item data for index checking&#10;                item_seg_index = seg_item.data(0, Qt.ItemDataRole.UserRole)&#10;                is_active = item_seg_index == seg_index&#10;&#10;                container = self.tree.itemWidget(seg_item, 1)&#10;                if container:&#10;                    buttons = container.findChildren(QPushButton)&#10;                    for btn in buttons:&#10;                        if btn.toolTip() == &quot;Set as active segment&quot;:&#10;                            print(&quot;setting active button for segment&quot;, seg_index)&#10;                            btn.setIcon(QIcon(ACTIVE_ICON if is_active else INACTIVE_ICON))&#10;&#10;        self.tree.viewport().update()&#10;        self.contour_editor.update()&#10;&#10;    def delete_segment(self, seg_index):&#10;        &quot;&quot;&quot;Delete a segment&quot;&quot;&quot;&#10;        if self.contour_editor:&#10;            print(f&quot;Deleting segment {seg_index}&quot;)&#10;            self.contour_editor.manager.delete_segment(seg_index)&#10;            self.contour_editor.update()&#10;            self.refresh_points()&#10;&#10;    def assign_segment_layer(self, seg_index, layer_name):&#10;        &quot;&quot;&quot;Assign a segment to a different layer&quot;&quot;&quot;&#10;        print(f&quot;Assigning Segment {seg_index} to layer '{layer_name}'&quot;)&#10;        if self.contour_editor:&#10;            self.contour_editor.manager.assign_segment_layer(seg_index, layer_name)&#10;            self.refresh_points()&#10;            self.contour_editor.update()&#10;&#10;    def handle_segment_toggle(self, item, column):&#10;        &quot;&quot;&quot;Handle segment toggle events&quot;&quot;&quot;&#10;        if not self.contour_editor:&#10;            return&#10;&#10;        # Layer visibility toggle&#10;        if item.parent() is None and column == 0:&#10;            layer_name = item.text(0)&#10;            visible = item.checkState(0) == Qt.CheckState.Checked&#10;            self.set_layer_visibility(layer_name, visible)&#10;            self.contour_editor.update()&#10;            return&#10;&#10;        # Segment visibility toggle&#10;        if item.parent() and column == 0:&#10;            # Use seg_item data for index checking&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    seg_index = int(seg_text[1:])&#10;                    visible = item.checkState(0) == Qt.CheckState.Checked&#10;                    self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;                    self.contour_editor.update()&#10;                except Exception as e:&#10;                    print(f&quot;[Error] segment visibility toggle: {e}&quot;)&#10;                return&#10;&#10;        # Segment activation toggle&#10;        if item.parent() and column == 2:&#10;            seg_text = item.text(0)&#10;            if seg_text.startswith(&quot;S&quot;):&#10;                try:&#10;                    seg_index = int(seg_text[1:])&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;                except Exception as e:&#10;                    print(f&quot;[Error] handle_segment_toggle: {e}&quot;)&#10;&#10;    def highlight_selected_point(self, item):&#10;        &quot;&quot;&quot;Handle point selection and highlighting&quot;&quot;&quot;&#10;        if not item or not self.contour_editor:&#10;            print(&quot;No item selected.&quot;)&#10;            return&#10;&#10;        print(f&quot;Item clicked: {item.text(0)}&quot;)&#10;&#10;        try:&#10;            # Handle segment selection&#10;            if item.text(0).startswith(&quot;S&quot;):&#10;                seg_index = int(item.text(0)[1:])&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;                return&#10;&#10;            # Handle point selection&#10;            parent = item.parent()&#10;            if parent and parent.text(0).startswith(&quot;S&quot;):&#10;                seg_index = int(parent.text(0)[1:])&#10;                label = item.text(0)&#10;&#10;                if label.startswith(&quot;P&quot;):&#10;                    idx = int(label[1:])&#10;                    self.contour_editor.selected_point_info = ('anchor', seg_index, idx)&#10;                elif label.startswith(&quot;C&quot;):&#10;                    idx = int(label[1:])&#10;                    self.contour_editor.selected_point_info = ('control', seg_index, idx)&#10;&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Selection error: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from unittest.mock import MagicMock&#10;&#10;    app = QApplication(sys.argv)&#10;    mock_contour_editor = MagicMock()&#10;    mock_manager = MagicMock()&#10;    mock_contour_editor.manager = mock_manager&#10;    widget = PointManagerWidget(contour_editor=mock_contour_editor)&#10;    widget.show()&#10;    sys.exit(app.exec())&#10;" />
              <option name="updatedContent" value="import os&#10;&#10;from PyQt6.QtCore import Qt, QPointF, QSize&#10;from PyQt6.QtGui import QIcon, QColor&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem,&#10;    QComboBox, QPushButton, QApplication, QHBoxLayout, QSizePolicy&#10;)&#10;from functools import partial&#10;from PyQt6.QtGui import QIcon, QFont&#10;&#10;from pl_gui.contour_editor.SegmentSettingsWidget import SegmentSettingsWidget&#10;from API.shared.settings.conreateSettings.enums.GlueSettingKey import GlueSettingKey&#10;from API.shared.settings.conreateSettings.enums.RobotSettingKey import RobotSettingKey&#10;from pl_gui.specific.enums.GlueType import GlueType&#10;from pl_gui.contour_editor.LayerButtonsWidget import LayerButtonsWidget&#10;from pl_gui.contour_editor.SegmentButtonsAndComboWidget import SegmentButtonsAndComboWidget&#10;from PyQt6.QtWidgets import QApplication&#10;import sys&#10;&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR,&quot;dropdown_open.png&quot;)&#10;&#10;class PointManagerWidget(QWidget):&#10;    def __init__(self, contour_editor=None):&#10;        super().__init__()&#10;        self.setLayout(QVBoxLayout())&#10;        self.layout().setContentsMargins(8, 8, 8, 8)&#10;        self.layout().setSpacing(4)&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QWidget {&#10;                font-size: 18px;&#10;            }&#10;            QPushButton {&#10;                min-width: 64px;&#10;                min-height: 64px;&#10;                padding: 10px;&#10;                border: None;&#10;            }&#10;            QComboBox {&#10;                min-height: 40px;&#10;                font-size: 18px;&#10;            }&#10;            QTreeWidget {&#10;                outline: none;&#10;                border: 1px solid #ccc;&#10;                background-color: white;&#10;            }&#10;            QTreeWidget::item {&#10;                height: 52px;&#10;                padding: 2px;&#10;            }&#10;            QTreeWidget::item:selected {&#10;                background-color: #e6f3ff;&#10;                border: 1px solid #007acc;&#10;            }&#10;            QTreeWidget::item:hover {&#10;                background-color: #f0f8ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.layout().setAlignment(Qt.AlignmentFlag.AlignTop)&#10;&#10;        self.contour_editor = contour_editor&#10;        if self.contour_editor:&#10;            self.contour_editor.pointsUpdated.connect(self.refresh_points)&#10;&#10;        self._setup_tree_widget()&#10;        self.layout().addWidget(self.tree)&#10;&#10;        self.layers = {}&#10;        self.is_drag_mode = False&#10;&#10;        self.initialize_tree_structure()&#10;&#10;    def _setup_tree_widget(self):&#10;        &quot;&quot;&quot;Initialize and configure the tree widget&quot;&quot;&quot;&#10;        self.tree = QTreeWidget()&#10;        # self.tree.setHeaderLabels([&quot;Layers&quot;, &quot;Controls&quot;])&#10;        self.tree.setHeaderLabels([&quot;&quot;])&#10;        self.tree.setRootIsDecorated(True)&#10;        self.tree.setAlternatingRowColors(True)&#10;        self.tree.setIndentation(20)&#10;&#10;        # Set initial column widths&#10;        self.tree.setColumnWidth(0, 120)&#10;        self.tree.setColumnWidth(1, 320)&#10;&#10;        # Connect signals&#10;        self.tree.itemClicked.connect(self.highlight_selected_point)&#10;        self.tree.itemChanged.connect(self.handle_segment_toggle)&#10;&#10;    def initialize_tree_structure(self):&#10;        &quot;&quot;&quot;Initialize the tree structure with layer items&quot;&quot;&quot;&#10;        self.tree.clear()&#10;        self.layers = {}&#10;&#10;        for name in [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]:&#10;            layer_item = self._create_layer_item(name)&#10;            self.tree.addTopLevelItem(layer_item)&#10;            self.layers[name] = layer_item&#10;&#10;            button_container = self._create_layer_button_container(name, layer_item)&#10;            self.tree.setItemWidget(layer_item, 0, button_container)&#10;&#10;        # Expand all layers by default&#10;        for layer_item in self.layers.values():&#10;            layer_item.setExpanded(True)&#10;&#10;    def _create_layer_item(self, name):&#10;        &quot;&quot;&quot;Create a layer item with proper configuration&quot;&quot;&quot;&#10;        layer_item = QTreeWidgetItem([])&#10;        layer_item.setFlags(layer_item.flags() &amp; ~Qt.ItemFlag.ItemIsUserCheckable)&#10;        layer_item.setFont(0, QFont(&quot;Arial&quot;, 16, QFont.Weight.Bold))&#10;        return layer_item&#10;&#10;    def _create_layer_button_container(self, layer_name, layer_item):&#10;&#10;        is_locked = self.contour_editor.manager.isLayerLocked(layer_name)&#10;&#10;        widget = LayerButtonsWidget(&#10;            layer_name=layer_name,&#10;            layer_item=layer_item,&#10;            on_visibility_toggle=lambda visible: self.set_layer_visibility(layer_name, visible),&#10;            on_add_segment=self._make_add_segment(layer_name, layer_item),&#10;            on_lock_toggle=self._make_layer_lock_toggle(layer_name),&#10;            is_locked=is_locked&#10;        )&#10;        return widget&#10;&#10;    def _make_layer_lock_toggle(self, layer_name):&#10;        def toggle_lock(locked):&#10;            if self.contour_editor:&#10;                self.contour_editor.set_layer_locked(layer_name, locked)&#10;                self.contour_editor.update()&#10;            print(f&quot;[ContourEditor] Set {layer_name} locked = {locked}&quot;)&#10;&#10;        return toggle_lock&#10;&#10;&#10;    def _make_add_segment(self, layer_name, layer_item):&#10;        &quot;&quot;&quot;Create an add segment function&quot;&quot;&quot;&#10;&#10;        def add_segment():&#10;            print(f&quot;Adding new segment to {layer_name}&quot;)&#10;            self.contour_editor.addNewSegment(layer_name)&#10;            self.refresh_points()&#10;&#10;            if layer_item:&#10;                self.tree.expandItem(layer_item)&#10;&#10;            # Force UI refresh&#10;            self.tree.viewport().update()&#10;&#10;        return add_segment&#10;&#10;    def set_layer_visibility(self, layer_name, visible):&#10;        &quot;&quot;&quot;Set the visibility of a layer&quot;&quot;&quot;&#10;        print(f&quot;[ContourEditor] Set {layer_name} visibility to {visible}&quot;)&#10;        self.contour_editor.set_layer_visibility(layer_name, visible)&#10;        self.update()&#10;&#10;    def get_current_selected_layer(self):&#10;        &quot;&quot;&quot;Get the currently selected layer name&quot;&quot;&quot;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            top_item = self.tree.topLevelItem(i)&#10;            if self.tree.currentItem() == top_item or top_item.isSelected():&#10;                return top_item.text(0)&#10;        return &quot;External&quot;&#10;&#10;    def refresh_points(self):&#10;        &quot;&quot;&quot;Refresh the points display in the tree&quot;&quot;&quot;&#10;        self.tree.blockSignals(True)&#10;        try:&#10;            if not self.contour_editor:&#10;                return&#10;&#10;            expanded_paths = self._save_expanded_state()&#10;            selected_path = self._save_selected_path()&#10;            # Remember the active segment index&#10;            active_segment_index = getattr(self.contour_editor.manager, &quot;active_segment_index&quot;, None)&#10;&#10;            self._clear_layer_children()&#10;            self._populate_segments()&#10;&#10;            self._restore_expanded_state(expanded_paths)&#10;            self._restore_selected_path(selected_path)&#10;            # Restore the active segment UI&#10;            if active_segment_index is not None:&#10;                self.set_active_segment_ui(active_segment_index)&#10;        finally:&#10;            self.tree.blockSignals(False)&#10;&#10;    def _save_expanded_state(self):&#10;        &quot;&quot;&quot;Save the current expanded state of tree items&quot;&quot;&quot;&#10;        expanded_paths = set()&#10;&#10;        def record_expansion(item, path=&quot;&quot;):&#10;            if item.isExpanded():&#10;                expanded_paths.add(path)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                record_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            record_expansion(item, item.text(0))&#10;&#10;        return expanded_paths&#10;&#10;    def _save_selected_path(self):&#10;        &quot;&quot;&quot;Save the path to the currently selected item&quot;&quot;&quot;&#10;        selected_item = self.tree.currentItem()&#10;        if not selected_item:&#10;            return None&#10;&#10;        path = []&#10;        node = selected_item&#10;        while node:&#10;            path.insert(0, node.text(0))&#10;            node = node.parent()&#10;        return &quot;/&quot;.join(path)&#10;&#10;    def _clear_layer_children(self):&#10;        &quot;&quot;&quot;Clear all children from layer items&quot;&quot;&quot;&#10;        for layer_item in self.layers.values():&#10;            layer_item.takeChildren()&#10;&#10;    def _populate_segments(self):&#10;        &quot;&quot;&quot;Populate segments in the tree structure&quot;&quot;&quot;&#10;        segments = self.contour_editor.manager.get_segments()&#10;        print(f&quot;Segments: {segments}&quot;)&#10;&#10;        for seg_index, segment in enumerate(segments):&#10;            layer = getattr(segment, &quot;layer&quot;)&#10;            if layer is None:&#10;                continue&#10;&#10;            print(f&quot;Segment {seg_index}: Layer = {layer}&quot;)&#10;            layer_name = layer.name&#10;&#10;            parent_layer = self.layers.get(layer_name)&#10;&#10;            # Create layer dynamically if it doesn't exist&#10;            if not parent_layer:&#10;                print(f&quot;Warning: Layer '{layer_name}' not found, creating it.&quot;)&#10;                parent_layer = self._create_layer_item(layer_name)&#10;                self.layers[layer_name] = parent_layer&#10;                self.tree.addTopLevelItem(parent_layer)&#10;&#10;            # Create segment item&#10;            # seg_item = QTreeWidgetItem([f&quot;S{seg_index}&quot;, &quot;&quot;])&#10;            seg_item = QTreeWidgetItem([&quot;&quot;])&#10;            seg_item.setFlags(seg_item.flags() &amp; ~Qt.ItemFlag.ItemIsEditable)&#10;            seg_item.setFont(0, QFont(&quot;Arial&quot;, 14))&#10;            parent_layer.addChild(seg_item)&#10;            # ✅ Store seg_index in the item&#10;            seg_item.setData(0, Qt.ItemDataRole.UserRole, seg_index)&#10;&#10;            # Create segment control widgets&#10;            seg_container = self._create_segment_container(seg_item, seg_index, segment, layer_name)&#10;            self.tree.setItemWidget(seg_item, 0, seg_container)&#10;&#10;            # Add point children&#10;            self._add_anchor_and_control_points(seg_item, segment)&#10;&#10;        print(&quot;Segments populated.&quot;)&#10;&#10;    def _create_segment_container(self, seg_item, seg_index, segment, layer_name):&#10;        def on_visibility(btn):&#10;            visible = btn.isChecked()&#10;            btn.setIcon(QIcon(HIDE_ICON if visible else SHOW_ICON))&#10;            self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;            self.contour_editor.update()&#10;&#10;        def on_activate():&#10;            self.set_active_segment_ui(seg_index)&#10;&#10;        def on_delete():&#10;            self.delete_segment(seg_index)&#10;&#10;        def on_settings():&#10;            self._on_settings_button_clicked(seg_index)&#10;&#10;        def on_layer_change(new_layer_name):&#10;            self.assign_segment_layer(seg_index, new_layer_name)&#10;&#10;        return SegmentButtonsAndComboWidget(&#10;            seg_index=seg_index,&#10;            segment=segment,&#10;            layer_name=layer_name,&#10;            on_visibility=on_visibility,&#10;            on_activate=on_activate,&#10;            on_delete=on_delete,&#10;            on_settings=on_settings,&#10;            on_layer_change=on_layer_change&#10;        )&#10;&#10;    def _show_settings_dialog(self,seg_index, segment):&#10;        # Prepare input keys for the settings widget&#10;        inputKeys = [key.value for key in GlueSettingKey]&#10;        if GlueSettingKey.GLUE_TYPE.value in inputKeys:&#10;            inputKeys.remove(GlueSettingKey.GLUE_TYPE.value)&#10;&#10;        inputKeys.append(RobotSettingKey.VELOCITY.value)&#10;        inputKeys.append(RobotSettingKey.ACCELERATION.value)&#10;&#10;        comboEnums = [[GlueSettingKey.GLUE_TYPE.value, GlueType]]&#10;&#10;        # Create the settings widget&#10;        from PyQt6.QtWidgets import QDialog, QVBoxLayout&#10;&#10;        dialog = QDialog()&#10;        dialog.setWindowTitle(f&quot;Segment {seg_index} Settings&quot;)&#10;        dialog.setMinimumWidth(400)&#10;        dialog.setMinimumHeight(300)&#10;&#10;        widget = SegmentSettingsWidget(inputKeys + [GlueSettingKey.GLUE_TYPE.value], comboEnums, segment=segment,&#10;                                       parent=dialog)&#10;        layout = QVBoxLayout(dialog)&#10;        layout.addWidget(widget)&#10;        dialog.setLayout(layout)&#10;&#10;        dialog.exec()  # This will keep the dialog open until closed explicitly&#10;&#10;    def _on_settings_button_clicked(self, seg_index):&#10;        segment = self.contour_editor.manager.get_segments()[seg_index]&#10;        layer = getattr(segment, &quot;layer&quot;, None)&#10;        layer_name = layer.name if layer else &quot;Unknown&quot;&#10;        print(f&quot;Settings button clicked for segment {seg_index} (Layer: {layer_name})&quot;)&#10;        self._show_settings_dialog(seg_index,segment)&#10;&#10;&#10;&#10;    def _add_anchor_and_control_points(self, seg_item, segment):&#10;        &quot;&quot;&quot;Add anchor and control points as children of the segment item&quot;&quot;&quot;&#10;        # Add anchor points&#10;        for i, pt in enumerate(segment.points):&#10;            coords = f&quot;({pt.x():.1f}, {pt.y():.1f})&quot; if isinstance(pt, QPointF) else &quot;Invalid&quot;&#10;            pt_item = QTreeWidgetItem([f&quot;P{i}&quot;, coords])&#10;            pt_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            pt_item.setForeground(0, QColor(&quot;#0066cc&quot;))&#10;            seg_item.addChild(pt_item)&#10;&#10;        # Add control points&#10;        for i, ctrl in enumerate(segment.controls):&#10;            coords = f&quot;({ctrl.x():.1f}, {ctrl.y():.1f})&quot; if isinstance(ctrl, QPointF) else &quot;Invalid&quot;&#10;            ctrl_item = QTreeWidgetItem([f&quot;C{i}&quot;, coords])&#10;            ctrl_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            ctrl_item.setForeground(0, QColor(&quot;#cc6600&quot;))&#10;            seg_item.addChild(ctrl_item)&#10;&#10;    def _restore_expanded_state(self, expanded_paths):&#10;        &quot;&quot;&quot;Restore the expanded state of tree items&quot;&quot;&quot;&#10;&#10;        def restore_expansion(item, path=&quot;&quot;):&#10;            if path in expanded_paths:&#10;                item.setExpanded(True)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                restore_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            restore_expansion(item, item.text(0))&#10;&#10;    def _restore_selected_path(self, selected_path):&#10;        &quot;&quot;&quot;Restore the selected item based on saved path&quot;&quot;&quot;&#10;        if not selected_path:&#10;            return&#10;&#10;        def find_item_by_path(root, path_parts):&#10;            if not path_parts:&#10;                return root&#10;            for i in range(root.childCount()):&#10;                child = root.child(i)&#10;                if child.text(0) == path_parts[0]:&#10;                    return find_item_by_path(child, path_parts[1:])&#10;            return None&#10;&#10;        path_parts = selected_path.split(&quot;/&quot;)&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            if item.text(0) == path_parts[0]:&#10;                target = find_item_by_path(item, path_parts[1:])&#10;                if target:&#10;                    self.tree.setCurrentItem(target)&#10;                    break&#10;&#10;    def set_active_segment_ui(self, seg_index):&#10;        &quot;&quot;&quot;Update UI to reflect the active segment&quot;&quot;&quot;&#10;        self.contour_editor.manager.set_active_segment(seg_index)&#10;        print(f&quot;[DEBUG] Set active segment to {seg_index}&quot;)&#10;&#10;        # Update all segment active buttons&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            layer_item = self.tree.topLevelItem(i)&#10;            for j in range(layer_item.childCount()):&#10;                seg_item = layer_item.child(j)&#10;                # Use seg_item data for index checking&#10;                item_seg_index = seg_item.data(0, Qt.ItemDataRole.UserRole)&#10;                is_active = item_seg_index == seg_index&#10;&#10;                container = self.tree.itemWidget(seg_item, 1)&#10;                if container:&#10;                    buttons = container.findChildren(QPushButton)&#10;                    for btn in buttons:&#10;                        if btn.toolTip() == &quot;Set as active segment&quot;:&#10;                            print(&quot;setting active button for segment&quot;, seg_index)&#10;                            btn.setIcon(QIcon(ACTIVE_ICON if is_active else INACTIVE_ICON))&#10;&#10;        self.tree.viewport().update()&#10;        self.contour_editor.update()&#10;&#10;    def delete_segment(self, seg_index):&#10;        &quot;&quot;&quot;Delete a segment&quot;&quot;&quot;&#10;        if self.contour_editor:&#10;            print(f&quot;Deleting segment {seg_index}&quot;)&#10;            self.contour_editor.manager.delete_segment(seg_index)&#10;            self.contour_editor.update()&#10;            self.refresh_points()&#10;&#10;    def assign_segment_layer(self, seg_index, layer_name):&#10;        &quot;&quot;&quot;Assign a segment to a different layer&quot;&quot;&quot;&#10;        print(f&quot;Assigning Segment {seg_index} to layer '{layer_name}'&quot;)&#10;        if self.contour_editor:&#10;            self.contour_editor.manager.assign_segment_layer(seg_index, layer_name)&#10;            self.refresh_points()&#10;            self.contour_editor.update()&#10;&#10;    def handle_segment_toggle(self, item, column):&#10;        &quot;&quot;&quot;Handle segment toggle events&quot;&quot;&quot;&#10;        if not self.contour_editor:&#10;            return&#10;&#10;        # Layer visibility toggle&#10;        if item.parent() is None and column == 0:&#10;            layer_name = item.text(0)&#10;            visible = item.checkState(0) == Qt.CheckState.Checked&#10;            self.set_layer_visibility(layer_name, visible)&#10;            self.contour_editor.update()&#10;            return&#10;&#10;        # Segment visibility toggle&#10;        if item.parent() and column == 0:&#10;            # Use seg_item data for index checking&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    visible = item.checkState(0) == Qt.CheckState.Checked&#10;                    self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;                    self.contour_editor.update()&#10;                except Exception as e:&#10;                    print(f&quot;[Error] segment visibility toggle: {e}&quot;)&#10;                return&#10;&#10;        # Segment activation toggle&#10;        if item.parent() and column == 2:&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;                except Exception as e:&#10;                    print(f&quot;[Error] handle_segment_toggle: {e}&quot;)&#10;&#10;    def highlight_selected_point(self, item):&#10;        &quot;&quot;&quot;Handle point selection and highlighting&quot;&quot;&quot;&#10;        if not item or not self.contour_editor:&#10;            print(&quot;No item selected.&quot;)&#10;            return&#10;&#10;        print(f&quot;Item clicked: {item.text(0)}&quot;)&#10;&#10;        try:&#10;            # Handle segment selection&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;                return&#10;&#10;            # Handle point selection&#10;            parent = item.parent()&#10;            if parent:&#10;                seg_index = parent.data(0, Qt.ItemDataRole.UserRole)&#10;                label = item.text(0)&#10;&#10;                if seg_index is not None:&#10;                    if label.startswith(&quot;P&quot;):&#10;                        idx = int(label[1:])&#10;                        self.contour_editor.selected_point_info = ('anchor', seg_index, idx)&#10;                    elif label.startswith(&quot;C&quot;):&#10;                        idx = int(label[1:])&#10;                        self.contour_editor.selected_point_info = ('control', seg_index, idx)&#10;&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Selection error: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from unittest.mock import MagicMock&#10;&#10;    app = QApplication(sys.argv)&#10;    mock_contour_editor = MagicMock()&#10;    mock_manager = MagicMock()&#10;    mock_contour_editor.manager = mock_manager&#10;    widget = PointManagerWidget(contour_editor=mock_contour_editor)&#10;    widget.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pl_gui/contour_editor/SegmentButtonsAndComboWidget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/contour_editor/SegmentButtonsAndComboWidget.py" />
              <option name="originalContent" value="import os&#10;import sys&#10;from types import SimpleNamespace&#10;&#10;from PyQt6.QtCore import Qt, QSize, QTimer&#10;from PyQt6.QtGui import QIcon&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy&#10;)&#10;from PyQt6.QtCore import Qt, QSize, QTimer, QPoint  # Add QPoint&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy, QMenu, QWidgetAction  # Add QMenu, QWidgetAction&#10;)&#10;&#10;# --- Resource Paths ---&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR, &quot;dropdown_open.png&quot;)&#10;GEAR_ICON = os.path.join(RESOURCE_DIR, &quot;SETTINGS_BUTTON.png&quot;)&#10;&#10;&#10;class LayerSelectionPopup(QMenu):&#10;    &quot;&quot;&quot;Custom popup menu for layer selection&quot;&quot;&quot;&#10;&#10;    def __init__(self, current_layer, on_layer_change, parent=None):&#10;        super().__init__(parent)&#10;        self.on_layer_change = on_layer_change&#10;        self.current_layer = current_layer&#10;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QMenu {&#10;                background-color: white;&#10;                border: 2px solid #007acc;&#10;                border-radius: 8px;&#10;                padding: 5px;&#10;                font-size: 14px;&#10;            }&#10;            QMenu::item {&#10;                padding: 8px 20px;&#10;                margin: 2px;&#10;                border-radius: 4px;&#10;            }&#10;            QMenu::item:selected {&#10;                background-color: #e6f3ff;&#10;                color: #007acc;&#10;            }&#10;            QMenu::item:pressed {&#10;                background-color: #cce7ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Add layer options&#10;        layers = [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]&#10;        for layer in layers:&#10;            action = self.addAction(layer)&#10;            action.triggered.connect(lambda checked, l=layer: self._on_layer_selected(l))&#10;&#10;            # Mark current layer&#10;            if layer == current_layer:&#10;                action.setText(f&quot;✓ {layer}&quot;)&#10;                action.setStyleSheet(&quot;font-weight: bold; color: #007acc;&quot;)&#10;&#10;    def _on_layer_selected(self, layer):&#10;        if self.on_layer_change:&#10;            self.on_layer_change(layer)&#10;&#10;class PressAndHoldButton(QPushButton):&#10;    &quot;&quot;&quot;Custom button that supports press and hold functionality&quot;&quot;&quot;&#10;&#10;    def __init__(self, text=&quot;&quot;, parent=None):&#10;        super().__init__(text, parent)&#10;&#10;        self.press_timer = QTimer()&#10;        self.press_timer.timeout.connect(self._on_long_press)&#10;        self.press_timer.setSingleShot(True)&#10;        self.long_press_duration = 500  # milliseconds&#10;        self.is_long_press = False&#10;&#10;        # Callbacks&#10;        self.on_click_callback = None&#10;        self.on_long_press_callback = None&#10;&#10;    def set_click_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for normal click&quot;&quot;&quot;&#10;        self.on_click_callback = callback&#10;&#10;    def set_long_press_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for long press&quot;&quot;&quot;&#10;        self.on_long_press_callback = callback&#10;&#10;    def mousePressEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.is_long_press = False&#10;            self.press_timer.start(self.long_press_duration)&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.press_timer.stop()&#10;&#10;            if not self.is_long_press:&#10;                # Normal click&#10;                if self.on_click_callback:&#10;                    self.on_click_callback()&#10;&#10;        super().mouseReleaseEvent(event)&#10;&#10;    def _on_long_press(self):&#10;        &quot;&quot;&quot;Handle long press event&quot;&quot;&quot;&#10;        self.is_long_press = True&#10;        if self.on_long_press_callback:&#10;            self.on_long_press_callback()&#10;&#10;class SegmentButtonsAndComboWidget(QWidget):&#10;    def __init__(self, seg_index, segment, layer_name,&#10;                 on_visibility, on_activate, on_delete, on_settings, on_layer_change,on_long_press):&#10;        super().__init__()&#10;&#10;        self.segment = segment&#10;        self.on_visibility = on_visibility&#10;        self.on_layer_change = on_layer_change&#10;        self.seg_index = seg_index&#10;        self.current_layer = layer_name&#10;&#10;        layout = QHBoxLayout(self)&#10;        layout.setContentsMargins(0, 0, 0, 0)&#10;        layout.setSpacing(8)&#10;        layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;&#10;        # Use custom press and hold button for index label&#10;        self.index_label = PressAndHoldButton(f&quot;S{seg_index}&quot;)&#10;        self.index_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)&#10;        self.index_label.setFixedHeight(50)&#10;        self.index_label.setFixedWidth(50)&#10;        self.index_label.setToolTip(&#10;            f&quot;Segment {seg_index} - Click to activate, Hold for layer options&quot;)  # Updated tooltip&#10;        self.index_label.setStyleSheet(&quot;text-align: center;&quot;)&#10;&#10;        # Set callbacks for press and hold&#10;        self.index_label.set_click_callback(on_activate)&#10;        self.index_label.set_long_press_callback(self._show_layer_popup)  # Changed this line&#10;&#10;        layout.addWidget(self.index_label)&#10;&#10;        # Buttons&#10;        self.visibility_btn = self._create_visibility_button()&#10;        layout.addWidget(self.visibility_btn)&#10;&#10;        # self.on_activate = on_activate&#10;        self.active_btn = self._create_icon_button(&#10;            ACTIVE_ICON if getattr(segment, &quot;is_active&quot;, False) else INACTIVE_ICON,&#10;            &quot;Set as active segment&quot;,&#10;            on_activate&#10;        )&#10;        # layout.addWidget(self.active_btn)&#10;&#10;        self.delete_btn = self._create_icon_button(&#10;            BIN_ICON, &quot;Delete this segment&quot;, on_delete&#10;        )&#10;        layout.addWidget(self.delete_btn)&#10;&#10;        # Updated settings button with gear icon&#10;        self.settings_btn = self._create_icon_button(&#10;            GEAR_ICON, &quot;Segment settings&quot;, on_settings&#10;        )&#10;        layout.addWidget(self.settings_btn)&#10;&#10;        # # Combo Box for Layer Selection&#10;        # self.combo_box = QComboBox()&#10;        # self.combo_box.addItems([&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;])&#10;        # self.combo_box.setCurrentText(layer_name)&#10;        # self.combo_box.setFixedHeight(50)&#10;        # self.combo_box.setMinimumWidth(100)&#10;        # self.combo_box.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)&#10;        # self.combo_box.currentTextChanged.connect(on_layer_change)&#10;        # layout.addWidget(self.combo_box)&#10;&#10;        layout.addStretch()&#10;&#10;    def _show_layer_popup(self):&#10;        &quot;&quot;&quot;Show layer selection popup on long press&quot;&quot;&quot;&#10;        popup = LayerSelectionPopup(&#10;            current_layer=self.current_layer,&#10;            on_layer_change=self._handle_layer_change,&#10;            parent=self&#10;        )&#10;&#10;        # Position popup near the button&#10;        button_pos = self.index_label.mapToGlobal(QPoint(0, 0))&#10;        popup_pos = QPoint(button_pos.x(), button_pos.y() + self.index_label.height() + 5)&#10;        popup.exec(popup_pos)&#10;&#10;    def _handle_layer_change(self, new_layer):&#10;        &quot;&quot;&quot;Handle layer change from popup&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;        if self.on_layer_change:&#10;            self.on_layer_change(new_layer)&#10;        print(f&quot;Layer changed to: {new_layer}&quot;)&#10;&#10;    def update_layer(self, new_layer):&#10;        &quot;&quot;&quot;Update the current layer (call this from parent when layer changes)&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;&#10;    def _create_icon_button(self, icon_path, tooltip, callback):&#10;        button = QPushButton()&#10;        button.setIcon(QIcon(icon_path))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(tooltip)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(callback)&#10;        return button&#10;&#10;    def _create_visibility_button(self):&#10;        button = QPushButton()&#10;        button.setCheckable(True)&#10;        is_visible = getattr(self.segment, &quot;visible&quot;, True)&#10;        button.setChecked(is_visible)&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(&quot;Toggle segment visibility&quot;)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(lambda: self._toggle_visibility(button))&#10;        return button&#10;&#10;    def _toggle_visibility(self, button):&#10;        is_visible = button.isChecked()&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        self.on_visibility(button)&#10;&#10;&#10;# --- Testing ---&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;&#10;    segment = SimpleNamespace(visible=True, is_active=False)&#10;    layer_name = &quot;Contour&quot;&#10;&#10;&#10;    def on_visibility(btn):&#10;        print(&quot;Visibility toggled:&quot;, btn.isChecked())&#10;&#10;&#10;    def on_activate():&#10;        print(&quot;Activated&quot;)&#10;&#10;&#10;    def on_delete():&#10;        print(&quot;Deleted&quot;)&#10;&#10;&#10;    def on_settings():&#10;        print(&quot;Settings opened&quot;)&#10;&#10;&#10;    def on_layer_change(value):&#10;        print(&quot;Layer changed to:&quot;, value)&#10;&#10;&#10;    def on_long_press(seg_index):&#10;        print(f&quot;Long press detected on segment {seg_index}!&quot;)&#10;&#10;&#10;    widget = SegmentButtonsAndComboWidget(&#10;        seg_index=0,&#10;        segment=segment,&#10;        layer_name=layer_name,&#10;        on_visibility=on_visibility,&#10;        on_activate=on_activate,&#10;        on_delete=on_delete,&#10;        on_settings=on_settings,&#10;        on_layer_change=on_layer_change,&#10;        on_long_press=on_long_press&#10;    )&#10;    widget.show()&#10;    sys.exit(app.exec())&#10;" />
              <option name="updatedContent" value="import os&#10;import sys&#10;from types import SimpleNamespace&#10;&#10;from PyQt6.QtCore import Qt, QSize, QTimer&#10;from PyQt6.QtGui import QIcon&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy&#10;)&#10;from PyQt6.QtCore import Qt, QSize, QTimer, QPoint  # Add QPoint&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy, QMenu, QWidgetAction  # Add QMenu, QWidgetAction&#10;)&#10;&#10;# --- Resource Paths ---&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR, &quot;dropdown_open.png&quot;)&#10;GEAR_ICON = os.path.join(RESOURCE_DIR, &quot;SETTINGS_BUTTON.png&quot;)&#10;&#10;&#10;class LayerSelectionPopup(QMenu):&#10;    &quot;&quot;&quot;Custom popup menu for layer selection&quot;&quot;&quot;&#10;&#10;    def __init__(self, current_layer, on_layer_change, parent=None):&#10;        super().__init__(parent)&#10;        self.on_layer_change = on_layer_change&#10;        self.current_layer = current_layer&#10;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QMenu {&#10;                background-color: white;&#10;                border: 2px solid #007acc;&#10;                border-radius: 8px;&#10;                padding: 5px;&#10;                font-size: 14px;&#10;            }&#10;            QMenu::item {&#10;                padding: 8px 20px;&#10;                margin: 2px;&#10;                border-radius: 4px;&#10;            }&#10;            QMenu::item:selected {&#10;                background-color: #e6f3ff;&#10;                color: #007acc;&#10;            }&#10;            QMenu::item:pressed {&#10;                background-color: #cce7ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Add layer options&#10;        layers = [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]&#10;        for layer in layers:&#10;            action = self.addAction(layer)&#10;            action.triggered.connect(lambda checked, l=layer: self._on_layer_selected(l))&#10;&#10;            # Mark current layer&#10;            if layer == current_layer:&#10;                action.setText(f&quot;✓ {layer}&quot;)&#10;&#10;    def _on_layer_selected(self, layer):&#10;        if self.on_layer_change:&#10;            self.on_layer_change(layer)&#10;&#10;class PressAndHoldButton(QPushButton):&#10;    &quot;&quot;&quot;Custom button that supports press and hold functionality&quot;&quot;&quot;&#10;&#10;    def __init__(self, text=&quot;&quot;, parent=None):&#10;        super().__init__(text, parent)&#10;&#10;        self.press_timer = QTimer()&#10;        self.press_timer.timeout.connect(self._on_long_press)&#10;        self.press_timer.setSingleShot(True)&#10;        self.long_press_duration = 500  # milliseconds&#10;        self.is_long_press = False&#10;&#10;        # Callbacks&#10;        self.on_click_callback = None&#10;        self.on_long_press_callback = None&#10;&#10;    def set_click_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for normal click&quot;&quot;&quot;&#10;        self.on_click_callback = callback&#10;&#10;    def set_long_press_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for long press&quot;&quot;&quot;&#10;        self.on_long_press_callback = callback&#10;&#10;    def mousePressEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.is_long_press = False&#10;            self.press_timer.start(self.long_press_duration)&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.press_timer.stop()&#10;&#10;            if not self.is_long_press:&#10;                # Normal click&#10;                if self.on_click_callback:&#10;                    self.on_click_callback()&#10;&#10;        super().mouseReleaseEvent(event)&#10;&#10;    def _on_long_press(self):&#10;        &quot;&quot;&quot;Handle long press event&quot;&quot;&quot;&#10;        self.is_long_press = True&#10;        if self.on_long_press_callback:&#10;            self.on_long_press_callback()&#10;&#10;class SegmentButtonsAndComboWidget(QWidget):&#10;    def __init__(self, seg_index, segment, layer_name,&#10;                 on_visibility, on_activate, on_delete, on_settings, on_layer_change,on_long_press):&#10;        super().__init__()&#10;&#10;        self.segment = segment&#10;        self.on_visibility = on_visibility&#10;        self.on_layer_change = on_layer_change&#10;        self.seg_index = seg_index&#10;        self.current_layer = layer_name&#10;&#10;        layout = QHBoxLayout(self)&#10;        layout.setContentsMargins(0, 0, 0, 0)&#10;        layout.setSpacing(8)&#10;        layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;&#10;        # Use custom press and hold button for index label&#10;        self.index_label = PressAndHoldButton(f&quot;S{seg_index}&quot;)&#10;        self.index_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)&#10;        self.index_label.setFixedHeight(50)&#10;        self.index_label.setFixedWidth(50)&#10;        self.index_label.setToolTip(&#10;            f&quot;Segment {seg_index} - Click to activate, Hold for layer options&quot;)  # Updated tooltip&#10;        self.index_label.setStyleSheet(&quot;text-align: center;&quot;)&#10;&#10;        # Set callbacks for press and hold&#10;        self.index_label.set_click_callback(on_activate)&#10;        self.index_label.set_long_press_callback(self._show_layer_popup)  # Changed this line&#10;&#10;        layout.addWidget(self.index_label)&#10;&#10;        # Buttons&#10;        self.visibility_btn = self._create_visibility_button()&#10;        layout.addWidget(self.visibility_btn)&#10;&#10;        # self.on_activate = on_activate&#10;        self.active_btn = self._create_icon_button(&#10;            ACTIVE_ICON if getattr(segment, &quot;is_active&quot;, False) else INACTIVE_ICON,&#10;            &quot;Set as active segment&quot;,&#10;            on_activate&#10;        )&#10;        # layout.addWidget(self.active_btn)&#10;&#10;        self.delete_btn = self._create_icon_button(&#10;            BIN_ICON, &quot;Delete this segment&quot;, on_delete&#10;        )&#10;        layout.addWidget(self.delete_btn)&#10;&#10;        # Updated settings button with gear icon&#10;        self.settings_btn = self._create_icon_button(&#10;            GEAR_ICON, &quot;Segment settings&quot;, on_settings&#10;        )&#10;        layout.addWidget(self.settings_btn)&#10;&#10;        # # Combo Box for Layer Selection&#10;        # self.combo_box = QComboBox()&#10;        # self.combo_box.addItems([&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;])&#10;        # self.combo_box.setCurrentText(layer_name)&#10;        # self.combo_box.setFixedHeight(50)&#10;        # self.combo_box.setMinimumWidth(100)&#10;        # self.combo_box.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)&#10;        # self.combo_box.currentTextChanged.connect(on_layer_change)&#10;        # layout.addWidget(self.combo_box)&#10;&#10;        layout.addStretch()&#10;&#10;    def _show_layer_popup(self):&#10;        &quot;&quot;&quot;Show layer selection popup on long press&quot;&quot;&quot;&#10;        popup = LayerSelectionPopup(&#10;            current_layer=self.current_layer,&#10;            on_layer_change=self._handle_layer_change,&#10;            parent=self&#10;        )&#10;&#10;        # Position popup near the button&#10;        button_pos = self.index_label.mapToGlobal(QPoint(0, 0))&#10;        popup_pos = QPoint(button_pos.x(), button_pos.y() + self.index_label.height() + 5)&#10;        popup.exec(popup_pos)&#10;&#10;    def _handle_layer_change(self, new_layer):&#10;        &quot;&quot;&quot;Handle layer change from popup&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;        if self.on_layer_change:&#10;            self.on_layer_change(new_layer)&#10;        print(f&quot;Layer changed to: {new_layer}&quot;)&#10;&#10;    def update_layer(self, new_layer):&#10;        &quot;&quot;&quot;Update the current layer (call this from parent when layer changes)&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;&#10;    def _create_icon_button(self, icon_path, tooltip, callback):&#10;        button = QPushButton()&#10;        button.setIcon(QIcon(icon_path))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(tooltip)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(callback)&#10;        return button&#10;&#10;    def _create_visibility_button(self):&#10;        button = QPushButton()&#10;        button.setCheckable(True)&#10;        is_visible = getattr(self.segment, &quot;visible&quot;, True)&#10;        button.setChecked(is_visible)&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(&quot;Toggle segment visibility&quot;)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(lambda: self._toggle_visibility(button))&#10;        return button&#10;&#10;    def _toggle_visibility(self, button):&#10;        is_visible = button.isChecked()&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        self.on_visibility(button)&#10;&#10;&#10;# --- Testing ---&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;&#10;    segment = SimpleNamespace(visible=True, is_active=False)&#10;    layer_name = &quot;Contour&quot;&#10;&#10;&#10;    def on_visibility(btn):&#10;        print(&quot;Visibility toggled:&quot;, btn.isChecked())&#10;&#10;&#10;    def on_activate():&#10;        print(&quot;Activated&quot;)&#10;&#10;&#10;    def on_delete():&#10;        print(&quot;Deleted&quot;)&#10;&#10;&#10;    def on_settings():&#10;        print(&quot;Settings opened&quot;)&#10;&#10;&#10;    def on_layer_change(value):&#10;        print(&quot;Layer changed to:&quot;, value)&#10;&#10;&#10;    def on_long_press(seg_index):&#10;        print(f&quot;Long press detected on segment {seg_index}!&quot;)&#10;&#10;&#10;    widget = SegmentButtonsAndComboWidget(&#10;        seg_index=0,&#10;        segment=segment,&#10;        layer_name=layer_name,&#10;        on_visibility=on_visibility,&#10;        on_activate=on_activate,&#10;        on_delete=on_delete,&#10;        on_settings=on_settings,&#10;        on_layer_change=on_layer_change,&#10;        on_long_press=on_long_press&#10;    )&#10;    widget.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>