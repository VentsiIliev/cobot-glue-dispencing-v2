<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pl_gui/contour_editor/PointManagerWidget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/contour_editor/PointManagerWidget.py" />
              <option name="originalContent" value="import os&#10;&#10;from PyQt6.QtCore import Qt, QPointF, QSize&#10;from PyQt6.QtGui import QIcon, QColor&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem,&#10;    QComboBox, QPushButton, QApplication, QHBoxLayout, QSizePolicy&#10;)&#10;from functools import partial&#10;from PyQt6.QtGui import QIcon, QFont&#10;&#10;from pl_gui.contour_editor.SegmentSettingsWidget import SegmentSettingsWidget&#10;from API.shared.settings.conreateSettings.enums.GlueSettingKey import GlueSettingKey&#10;from API.shared.settings.conreateSettings.enums.RobotSettingKey import RobotSettingKey&#10;from pl_gui.specific.enums.GlueType import GlueType&#10;from pl_gui.contour_editor.LayerButtonsWidget import LayerButtonsWidget&#10;from pl_gui.contour_editor.SegmentButtonsAndComboWidget import SegmentButtonsAndComboWidget&#10;from PyQt6.QtWidgets import QApplication&#10;import sys&#10;&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR,&quot;dropdown_open.png&quot;)&#10;&#10;class PointManagerWidget(QWidget):&#10;    def __init__(self, contour_editor=None):&#10;        super().__init__()&#10;        self.setLayout(QVBoxLayout())&#10;        self.layout().setContentsMargins(8, 8, 8, 8)&#10;        self.layout().setSpacing(4)&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QWidget {&#10;                font-size: 18px;&#10;            }&#10;            QPushButton {&#10;                min-width: 64px;&#10;                min-height: 64px;&#10;                padding: 10px;&#10;                border: None;&#10;            }&#10;            QComboBox {&#10;                min-height: 40px;&#10;                font-size: 18px;&#10;            }&#10;            QTreeWidget {&#10;                outline: none;&#10;                border: 1px solid #ccc;&#10;                background-color: white;&#10;            }&#10;            QTreeWidget::item {&#10;                height: 52px;&#10;                padding: 2px;&#10;            }&#10;            QTreeWidget::item:selected {&#10;                background-color: #e6f3ff;&#10;                border: 1px solid #007acc;&#10;            }&#10;            QTreeWidget::item:hover {&#10;                background-color: #f0f8ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.layout().setAlignment(Qt.AlignmentFlag.AlignTop)&#10;&#10;        self.contour_editor = contour_editor&#10;        if self.contour_editor:&#10;            self.contour_editor.pointsUpdated.connect(self.refresh_points)&#10;&#10;        self._setup_tree_widget()&#10;        self.layout().addWidget(self.tree)&#10;&#10;        self.layers = {}&#10;        self.is_drag_mode = False&#10;&#10;        self.initialize_tree_structure()&#10;&#10;    def _setup_tree_widget(self):&#10;        &quot;&quot;&quot;Initialize and configure the tree widget&quot;&quot;&quot;&#10;        self.tree = QTreeWidget()&#10;        # self.tree.setHeaderLabels([&quot;Layers&quot;, &quot;Controls&quot;])&#10;        self.tree.setHeaderLabels([&quot;&quot;])&#10;        self.tree.setRootIsDecorated(True)&#10;        self.tree.setAlternatingRowColors(True)&#10;        self.tree.setIndentation(20)&#10;&#10;        # Set initial column widths&#10;        self.tree.setColumnWidth(0, 120)&#10;        self.tree.setColumnWidth(1, 320)&#10;&#10;        # Connect signals&#10;        self.tree.itemClicked.connect(self.highlight_selected_point)&#10;        self.tree.itemChanged.connect(self.handle_segment_toggle)&#10;&#10;    def initialize_tree_structure(self):&#10;        &quot;&quot;&quot;Initialize the tree structure with layer items&quot;&quot;&quot;&#10;        self.tree.clear()&#10;        self.layers = {}&#10;&#10;        for name in [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]:&#10;            layer_item = self._create_layer_item(name)&#10;            self.tree.addTopLevelItem(layer_item)&#10;            self.layers[name] = layer_item&#10;&#10;            button_container = self._create_layer_button_container(name, layer_item)&#10;            self.tree.setItemWidget(layer_item, 0, button_container)&#10;&#10;        # Expand all layers by default&#10;        for layer_item in self.layers.values():&#10;            layer_item.setExpanded(True)&#10;&#10;    def _create_layer_item(self, name):&#10;        &quot;&quot;&quot;Create a layer item with proper configuration&quot;&quot;&quot;&#10;        layer_item = QTreeWidgetItem([])&#10;        layer_item.setFlags(layer_item.flags() &amp; ~Qt.ItemFlag.ItemIsUserCheckable)&#10;        layer_item.setFont(0, QFont(&quot;Arial&quot;, 16, QFont.Weight.Bold))&#10;        return layer_item&#10;&#10;    def _create_layer_button_container(self, layer_name, layer_item):&#10;&#10;        is_locked = self.contour_editor.manager.isLayerLocked(layer_name)&#10;&#10;        widget = LayerButtonsWidget(&#10;            layer_name=layer_name,&#10;            layer_item=layer_item,&#10;            on_visibility_toggle=lambda visible: self.set_layer_visibility(layer_name, visible),&#10;            on_add_segment=self._make_add_segment(layer_name, layer_item),&#10;            on_lock_toggle=self._make_layer_lock_toggle(layer_name),&#10;            is_locked=is_locked&#10;        )&#10;        return widget&#10;&#10;    def _make_layer_lock_toggle(self, layer_name):&#10;        def toggle_lock(locked):&#10;            if self.contour_editor:&#10;                self.contour_editor.set_layer_locked(layer_name, locked)&#10;                self.contour_editor.update()&#10;            print(f&quot;[ContourEditor] Set {layer_name} locked = {locked}&quot;)&#10;&#10;        return toggle_lock&#10;&#10;&#10;    def _make_add_segment(self, layer_name, layer_item):&#10;        &quot;&quot;&quot;Create an add segment function&quot;&quot;&quot;&#10;&#10;        def add_segment():&#10;            print(f&quot;Adding new segment to {layer_name}&quot;)&#10;            self.contour_editor.addNewSegment(layer_name)&#10;            self.refresh_points()&#10;&#10;            if layer_item:&#10;                self.tree.expandItem(layer_item)&#10;&#10;            # Force UI refresh&#10;            self.tree.viewport().update()&#10;&#10;        return add_segment&#10;&#10;    def set_layer_visibility(self, layer_name, visible):&#10;        &quot;&quot;&quot;Set the visibility of a layer&quot;&quot;&quot;&#10;        print(f&quot;[ContourEditor] Set {layer_name} visibility to {visible}&quot;)&#10;        self.contour_editor.set_layer_visibility(layer_name, visible)&#10;        self.update()&#10;&#10;    def get_current_selected_layer(self):&#10;        &quot;&quot;&quot;Get the currently selected layer name&quot;&quot;&quot;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            top_item = self.tree.topLevelItem(i)&#10;            if self.tree.currentItem() == top_item or top_item.isSelected():&#10;                return top_item.text(0)&#10;        return &quot;External&quot;&#10;&#10;    def refresh_points(self):&#10;        &quot;&quot;&quot;Refresh the points display in the tree&quot;&quot;&quot;&#10;        self.tree.blockSignals(True)&#10;        try:&#10;            if not self.contour_editor:&#10;                return&#10;&#10;            expanded_paths = self._save_expanded_state()&#10;            selected_path = self._save_selected_path()&#10;            # Remember the active segment index&#10;            active_segment_index = getattr(self.contour_editor.manager, &quot;active_segment_index&quot;, None)&#10;&#10;            self._clear_layer_children()&#10;            self._populate_segments()&#10;&#10;            self._restore_expanded_state(expanded_paths)&#10;            self._restore_selected_path(selected_path)&#10;            # Restore the active segment UI&#10;            if active_segment_index is not None:&#10;                self.set_active_segment_ui(active_segment_index)&#10;        finally:&#10;            self.tree.blockSignals(False)&#10;&#10;    def _save_expanded_state(self):&#10;        &quot;&quot;&quot;Save the current expanded state of tree items&quot;&quot;&quot;&#10;        expanded_paths = set()&#10;&#10;        def record_expansion(item, path=&quot;&quot;):&#10;            if item.isExpanded():&#10;                expanded_paths.add(path)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                record_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            record_expansion(item, item.text(0))&#10;&#10;        return expanded_paths&#10;&#10;    def _save_selected_path(self):&#10;        &quot;&quot;&quot;Save the path to the currently selected item&quot;&quot;&quot;&#10;        selected_item = self.tree.currentItem()&#10;        if not selected_item:&#10;            return None&#10;&#10;        path = []&#10;        node = selected_item&#10;        while node:&#10;            path.insert(0, node.text(0))&#10;            node = node.parent()&#10;        return &quot;/&quot;.join(path)&#10;&#10;    def _clear_layer_children(self):&#10;        &quot;&quot;&quot;Clear all children from layer items&quot;&quot;&quot;&#10;        for layer_item in self.layers.values():&#10;            layer_item.takeChildren()&#10;&#10;    def _populate_segments(self):&#10;        &quot;&quot;&quot;Populate segments in the tree structure&quot;&quot;&quot;&#10;        segments = self.contour_editor.manager.get_segments()&#10;        print(f&quot;Segments: {segments}&quot;)&#10;&#10;        for seg_index, segment in enumerate(segments):&#10;            layer = getattr(segment, &quot;layer&quot;)&#10;            if layer is None:&#10;                continue&#10;&#10;            print(f&quot;Segment {seg_index}: Layer = {layer}&quot;)&#10;            layer_name = layer.name&#10;&#10;            parent_layer = self.layers.get(layer_name)&#10;&#10;            # Create layer dynamically if it doesn't exist&#10;            if not parent_layer:&#10;                print(f&quot;Warning: Layer '{layer_name}' not found, creating it.&quot;)&#10;                parent_layer = self._create_layer_item(layer_name)&#10;                self.layers[layer_name] = parent_layer&#10;                self.tree.addTopLevelItem(parent_layer)&#10;&#10;            # Create segment item&#10;            # seg_item = QTreeWidgetItem([f&quot;S{seg_index}&quot;, &quot;&quot;])&#10;            seg_item = QTreeWidgetItem([&quot;&quot;])&#10;            seg_item.setFlags(seg_item.flags() &amp; ~Qt.ItemFlag.ItemIsEditable)&#10;            seg_item.setFont(0, QFont(&quot;Arial&quot;, 14))&#10;            parent_layer.addChild(seg_item)&#10;            # ✅ Store seg_index in the item&#10;            seg_item.setData(0, Qt.ItemDataRole.UserRole, seg_index)&#10;&#10;            # Create segment control widgets&#10;            seg_container = self._create_segment_container(seg_item, seg_index, segment, layer_name)&#10;            self.tree.setItemWidget(seg_item, 0, seg_container)&#10;&#10;            # Add point children&#10;            self._add_anchor_and_control_points(seg_item, segment)&#10;&#10;        print(&quot;Segments populated.&quot;)&#10;&#10;    def _create_segment_container(self, seg_item, seg_index, segment, layer_name):&#10;        def on_visibility(btn):&#10;            visible = btn.isChecked()&#10;            btn.setIcon(QIcon(HIDE_ICON if visible else SHOW_ICON))&#10;            self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;            self.contour_editor.update()&#10;&#10;        def on_activate():&#10;            self.set_active_segment_ui(seg_index)&#10;&#10;        def on_delete():&#10;            self.delete_segment(seg_index)&#10;&#10;        def on_settings():&#10;            self._on_settings_button_clicked(seg_index)&#10;&#10;        def on_layer_change(new_layer_name):&#10;            self.assign_segment_layer(seg_index, new_layer_name)&#10;&#10;        return SegmentButtonsAndComboWidget(&#10;            seg_index=seg_index,&#10;            segment=segment,&#10;            layer_name=layer_name,&#10;            on_visibility=on_visibility,&#10;            on_activate=on_activate,&#10;            on_delete=on_delete,&#10;            on_settings=on_settings,&#10;            on_layer_change=on_layer_change&#10;        )&#10;&#10;    def _show_settings_dialog(self,seg_index, segment):&#10;        # Prepare input keys for the settings widget&#10;        inputKeys = [key.value for key in GlueSettingKey]&#10;        if GlueSettingKey.GLUE_TYPE.value in inputKeys:&#10;            inputKeys.remove(GlueSettingKey.GLUE_TYPE.value)&#10;&#10;        inputKeys.append(RobotSettingKey.VELOCITY.value)&#10;        inputKeys.append(RobotSettingKey.ACCELERATION.value)&#10;&#10;        comboEnums = [[GlueSettingKey.GLUE_TYPE.value, GlueType]]&#10;&#10;        # Create the settings widget&#10;        from PyQt6.QtWidgets import QDialog, QVBoxLayout&#10;&#10;        dialog = QDialog()&#10;        dialog.setWindowTitle(f&quot;Segment {seg_index} Settings&quot;)&#10;        dialog.setMinimumWidth(400)&#10;        dialog.setMinimumHeight(300)&#10;&#10;        widget = SegmentSettingsWidget(inputKeys + [GlueSettingKey.GLUE_TYPE.value], comboEnums, segment=segment,&#10;                                       parent=dialog)&#10;        layout = QVBoxLayout(dialog)&#10;        layout.addWidget(widget)&#10;        dialog.setLayout(layout)&#10;&#10;        dialog.exec()  # This will keep the dialog open until closed explicitly&#10;&#10;    def _on_settings_button_clicked(self, seg_index):&#10;        segment = self.contour_editor.manager.get_segments()[seg_index]&#10;        layer = getattr(segment, &quot;layer&quot;, None)&#10;        layer_name = layer.name if layer else &quot;Unknown&quot;&#10;        print(f&quot;Settings button clicked for segment {seg_index} (Layer: {layer_name})&quot;)&#10;        self._show_settings_dialog(seg_index,segment)&#10;&#10;&#10;&#10;    def _add_anchor_and_control_points(self, seg_item, segment):&#10;        &quot;&quot;&quot;Add anchor and control points as children of the segment item&quot;&quot;&quot;&#10;        # Add anchor points&#10;        for i, pt in enumerate(segment.points):&#10;            coords = f&quot;({pt.x():.1f}, {pt.y():.1f})&quot; if isinstance(pt, QPointF) else &quot;Invalid&quot;&#10;            pt_item = QTreeWidgetItem([f&quot;P{i}&quot;, coords])&#10;            pt_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            pt_item.setForeground(0, QColor(&quot;#0066cc&quot;))&#10;            seg_item.addChild(pt_item)&#10;&#10;        # Add control points&#10;        for i, ctrl in enumerate(segment.controls):&#10;            coords = f&quot;({ctrl.x():.1f}, {ctrl.y():.1f})&quot; if isinstance(ctrl, QPointF) else &quot;Invalid&quot;&#10;            ctrl_item = QTreeWidgetItem([f&quot;C{i}&quot;, coords])&#10;            ctrl_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            ctrl_item.setForeground(0, QColor(&quot;#cc6600&quot;))&#10;            seg_item.addChild(ctrl_item)&#10;&#10;    def _restore_expanded_state(self, expanded_paths):&#10;        &quot;&quot;&quot;Restore the expanded state of tree items&quot;&quot;&quot;&#10;&#10;        def restore_expansion(item, path=&quot;&quot;):&#10;            if path in expanded_paths:&#10;                item.setExpanded(True)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                restore_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            restore_expansion(item, item.text(0))&#10;&#10;    def _restore_selected_path(self, selected_path):&#10;        &quot;&quot;&quot;Restore the selected item based on saved path&quot;&quot;&quot;&#10;        if not selected_path:&#10;            return&#10;&#10;        def find_item_by_path(root, path_parts):&#10;            if not path_parts:&#10;                return root&#10;            for i in range(root.childCount()):&#10;                child = root.child(i)&#10;                if child.text(0) == path_parts[0]:&#10;                    return find_item_by_path(child, path_parts[1:])&#10;            return None&#10;&#10;        path_parts = selected_path.split(&quot;/&quot;)&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            if item.text(0) == path_parts[0]:&#10;                target = find_item_by_path(item, path_parts[1:])&#10;                if target:&#10;                    self.tree.setCurrentItem(target)&#10;                    break&#10;&#10;    def set_active_segment_ui(self, seg_index):&#10;        &quot;&quot;&quot;Update UI to reflect the active segment&quot;&quot;&quot;&#10;        self.contour_editor.manager.set_active_segment(seg_index)&#10;        print(f&quot;[DEBUG] Set active segment to {seg_index}&quot;)&#10;&#10;        # Update all segment active buttons&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            layer_item = self.tree.topLevelItem(i)&#10;            for j in range(layer_item.childCount()):&#10;                seg_item = layer_item.child(j)&#10;                # Use seg_item data for index checking&#10;                item_seg_index = seg_item.data(0, Qt.ItemDataRole.UserRole)&#10;                is_active = item_seg_index == seg_index&#10;&#10;                container = self.tree.itemWidget(seg_item, 1)&#10;                if container:&#10;                    buttons = container.findChildren(QPushButton)&#10;                    for btn in buttons:&#10;                        if btn.toolTip() == &quot;Set as active segment&quot;:&#10;                            print(&quot;setting active button for segment&quot;, seg_index)&#10;                            btn.setIcon(QIcon(ACTIVE_ICON if is_active else INACTIVE_ICON))&#10;&#10;        self.tree.viewport().update()&#10;        self.contour_editor.update()&#10;&#10;    def delete_segment(self, seg_index):&#10;        &quot;&quot;&quot;Delete a segment&quot;&quot;&quot;&#10;        if self.contour_editor:&#10;            print(f&quot;Deleting segment {seg_index}&quot;)&#10;            self.contour_editor.manager.delete_segment(seg_index)&#10;            self.contour_editor.update()&#10;            self.refresh_points()&#10;&#10;    def assign_segment_layer(self, seg_index, layer_name):&#10;        &quot;&quot;&quot;Assign a segment to a different layer&quot;&quot;&quot;&#10;        print(f&quot;Assigning Segment {seg_index} to layer '{layer_name}'&quot;)&#10;        if self.contour_editor:&#10;            self.contour_editor.manager.assign_segment_layer(seg_index, layer_name)&#10;            self.refresh_points()&#10;            self.contour_editor.update()&#10;&#10;    def handle_segment_toggle(self, item, column):&#10;        &quot;&quot;&quot;Handle segment toggle events&quot;&quot;&quot;&#10;        if not self.contour_editor:&#10;            return&#10;&#10;        # Layer visibility toggle&#10;        if item.parent() is None and column == 0:&#10;            layer_name = item.text(0)&#10;            visible = item.checkState(0) == Qt.CheckState.Checked&#10;            self.set_layer_visibility(layer_name, visible)&#10;            self.contour_editor.update()&#10;            return&#10;&#10;        # Segment visibility toggle&#10;        if item.parent() and column == 0:&#10;            # Use seg_item data for index checking&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    seg_index = int(seg_text[1:])&#10;                    visible = item.checkState(0) == Qt.CheckState.Checked&#10;                    self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;                    self.contour_editor.update()&#10;                except Exception as e:&#10;                    print(f&quot;[Error] segment visibility toggle: {e}&quot;)&#10;                return&#10;&#10;        # Segment activation toggle&#10;        if item.parent() and column == 2:&#10;            seg_text = item.text(0)&#10;            if seg_text.startswith(&quot;S&quot;):&#10;                try:&#10;                    seg_index = int(seg_text[1:])&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;                except Exception as e:&#10;                    print(f&quot;[Error] handle_segment_toggle: {e}&quot;)&#10;&#10;    def highlight_selected_point(self, item):&#10;        &quot;&quot;&quot;Handle point selection and highlighting&quot;&quot;&quot;&#10;        if not item or not self.contour_editor:&#10;            print(&quot;No item selected.&quot;)&#10;            return&#10;&#10;        print(f&quot;Item clicked: {item.text(0)}&quot;)&#10;&#10;        try:&#10;            # Handle segment selection&#10;            if item.text(0).startswith(&quot;S&quot;):&#10;                seg_index = int(item.text(0)[1:])&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;                return&#10;&#10;            # Handle point selection&#10;            parent = item.parent()&#10;            if parent and parent.text(0).startswith(&quot;S&quot;):&#10;                seg_index = int(parent.text(0)[1:])&#10;                label = item.text(0)&#10;&#10;                if label.startswith(&quot;P&quot;):&#10;                    idx = int(label[1:])&#10;                    self.contour_editor.selected_point_info = ('anchor', seg_index, idx)&#10;                elif label.startswith(&quot;C&quot;):&#10;                    idx = int(label[1:])&#10;                    self.contour_editor.selected_point_info = ('control', seg_index, idx)&#10;&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Selection error: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from unittest.mock import MagicMock&#10;&#10;    app = QApplication(sys.argv)&#10;    mock_contour_editor = MagicMock()&#10;    mock_manager = MagicMock()&#10;    mock_contour_editor.manager = mock_manager&#10;    widget = PointManagerWidget(contour_editor=mock_contour_editor)&#10;    widget.show()&#10;    sys.exit(app.exec())&#10;" />
              <option name="updatedContent" value="import os&#10;&#10;from PyQt6.QtCore import Qt, QPointF, QSize&#10;from PyQt6.QtGui import QIcon, QColor&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem,&#10;    QComboBox, QPushButton, QApplication, QHBoxLayout, QSizePolicy&#10;)&#10;from functools import partial&#10;from PyQt6.QtGui import QIcon, QFont&#10;&#10;from pl_gui.contour_editor.SegmentSettingsWidget import SegmentSettingsWidget&#10;from API.shared.settings.conreateSettings.enums.GlueSettingKey import GlueSettingKey&#10;from API.shared.settings.conreateSettings.enums.RobotSettingKey import RobotSettingKey&#10;from pl_gui.specific.enums.GlueType import GlueType&#10;from pl_gui.contour_editor.LayerButtonsWidget import LayerButtonsWidget&#10;from pl_gui.contour_editor.SegmentButtonsAndComboWidget import SegmentButtonsAndComboWidget&#10;from PyQt6.QtWidgets import QApplication&#10;import sys&#10;&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR,&quot;dropdown_open.png&quot;)&#10;&#10;class PointManagerWidget(QWidget):&#10;    def __init__(self, contour_editor=None):&#10;        super().__init__()&#10;        self.setLayout(QVBoxLayout())&#10;        self.layout().setContentsMargins(8, 8, 8, 8)&#10;        self.layout().setSpacing(4)&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QWidget {&#10;                font-size: 18px;&#10;            }&#10;            QPushButton {&#10;                min-width: 64px;&#10;                min-height: 64px;&#10;                padding: 10px;&#10;                border: None;&#10;            }&#10;            QComboBox {&#10;                min-height: 40px;&#10;                font-size: 18px;&#10;            }&#10;            QTreeWidget {&#10;                outline: none;&#10;                border: 1px solid #ccc;&#10;                background-color: white;&#10;            }&#10;            QTreeWidget::item {&#10;                height: 52px;&#10;                padding: 2px;&#10;            }&#10;            QTreeWidget::item:selected {&#10;                background-color: #e6f3ff;&#10;                border: 1px solid #007acc;&#10;            }&#10;            QTreeWidget::item:hover {&#10;                background-color: #f0f8ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.layout().setAlignment(Qt.AlignmentFlag.AlignTop)&#10;&#10;        self.contour_editor = contour_editor&#10;        if self.contour_editor:&#10;            self.contour_editor.pointsUpdated.connect(self.refresh_points)&#10;&#10;        self._setup_tree_widget()&#10;        self.layout().addWidget(self.tree)&#10;&#10;        self.layers = {}&#10;        self.is_drag_mode = False&#10;&#10;        self.initialize_tree_structure()&#10;&#10;    def _setup_tree_widget(self):&#10;        &quot;&quot;&quot;Initialize and configure the tree widget&quot;&quot;&quot;&#10;        self.tree = QTreeWidget()&#10;        # self.tree.setHeaderLabels([&quot;Layers&quot;, &quot;Controls&quot;])&#10;        self.tree.setHeaderLabels([&quot;&quot;])&#10;        self.tree.setRootIsDecorated(True)&#10;        self.tree.setAlternatingRowColors(True)&#10;        self.tree.setIndentation(20)&#10;&#10;        # Set initial column widths&#10;        self.tree.setColumnWidth(0, 120)&#10;        self.tree.setColumnWidth(1, 320)&#10;&#10;        # Connect signals&#10;        self.tree.itemClicked.connect(self.highlight_selected_point)&#10;        self.tree.itemChanged.connect(self.handle_segment_toggle)&#10;&#10;    def initialize_tree_structure(self):&#10;        &quot;&quot;&quot;Initialize the tree structure with layer items&quot;&quot;&quot;&#10;        self.tree.clear()&#10;        self.layers = {}&#10;&#10;        for name in [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]:&#10;            layer_item = self._create_layer_item(name)&#10;            self.tree.addTopLevelItem(layer_item)&#10;            self.layers[name] = layer_item&#10;&#10;            button_container = self._create_layer_button_container(name, layer_item)&#10;            self.tree.setItemWidget(layer_item, 0, button_container)&#10;&#10;        # Expand all layers by default&#10;        for layer_item in self.layers.values():&#10;            layer_item.setExpanded(True)&#10;&#10;    def _create_layer_item(self, name):&#10;        &quot;&quot;&quot;Create a layer item with proper configuration&quot;&quot;&quot;&#10;        layer_item = QTreeWidgetItem([])&#10;        layer_item.setFlags(layer_item.flags() &amp; ~Qt.ItemFlag.ItemIsUserCheckable)&#10;        layer_item.setFont(0, QFont(&quot;Arial&quot;, 16, QFont.Weight.Bold))&#10;        return layer_item&#10;&#10;    def _create_layer_button_container(self, layer_name, layer_item):&#10;&#10;        is_locked = self.contour_editor.manager.isLayerLocked(layer_name)&#10;&#10;        widget = LayerButtonsWidget(&#10;            layer_name=layer_name,&#10;            layer_item=layer_item,&#10;            on_visibility_toggle=lambda visible: self.set_layer_visibility(layer_name, visible),&#10;            on_add_segment=self._make_add_segment(layer_name, layer_item),&#10;            on_lock_toggle=self._make_layer_lock_toggle(layer_name),&#10;            is_locked=is_locked&#10;        )&#10;        return widget&#10;&#10;    def _make_layer_lock_toggle(self, layer_name):&#10;        def toggle_lock(locked):&#10;            if self.contour_editor:&#10;                self.contour_editor.set_layer_locked(layer_name, locked)&#10;                self.contour_editor.update()&#10;            print(f&quot;[ContourEditor] Set {layer_name} locked = {locked}&quot;)&#10;&#10;        return toggle_lock&#10;&#10;&#10;    def _make_add_segment(self, layer_name, layer_item):&#10;        &quot;&quot;&quot;Create an add segment function&quot;&quot;&quot;&#10;&#10;        def add_segment():&#10;            print(f&quot;Adding new segment to {layer_name}&quot;)&#10;            self.contour_editor.addNewSegment(layer_name)&#10;            self.refresh_points()&#10;&#10;            if layer_item:&#10;                self.tree.expandItem(layer_item)&#10;&#10;            # Force UI refresh&#10;            self.tree.viewport().update()&#10;&#10;        return add_segment&#10;&#10;    def set_layer_visibility(self, layer_name, visible):&#10;        &quot;&quot;&quot;Set the visibility of a layer&quot;&quot;&quot;&#10;        print(f&quot;[ContourEditor] Set {layer_name} visibility to {visible}&quot;)&#10;        self.contour_editor.set_layer_visibility(layer_name, visible)&#10;        self.update()&#10;&#10;    def get_current_selected_layer(self):&#10;        &quot;&quot;&quot;Get the currently selected layer name&quot;&quot;&quot;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            top_item = self.tree.topLevelItem(i)&#10;            if self.tree.currentItem() == top_item or top_item.isSelected():&#10;                return top_item.text(0)&#10;        return &quot;External&quot;&#10;&#10;    def refresh_points(self):&#10;        &quot;&quot;&quot;Refresh the points display in the tree&quot;&quot;&quot;&#10;        self.tree.blockSignals(True)&#10;        try:&#10;            if not self.contour_editor:&#10;                return&#10;&#10;            expanded_paths = self._save_expanded_state()&#10;            selected_path = self._save_selected_path()&#10;            # Remember the active segment index&#10;            active_segment_index = getattr(self.contour_editor.manager, &quot;active_segment_index&quot;, None)&#10;&#10;            self._clear_layer_children()&#10;            self._populate_segments()&#10;&#10;            self._restore_expanded_state(expanded_paths)&#10;            self._restore_selected_path(selected_path)&#10;            # Restore the active segment UI&#10;            if active_segment_index is not None:&#10;                self.set_active_segment_ui(active_segment_index)&#10;        finally:&#10;            self.tree.blockSignals(False)&#10;&#10;    def _save_expanded_state(self):&#10;        &quot;&quot;&quot;Save the current expanded state of tree items&quot;&quot;&quot;&#10;        expanded_paths = set()&#10;&#10;        def record_expansion(item, path=&quot;&quot;):&#10;            if item.isExpanded():&#10;                expanded_paths.add(path)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                record_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            record_expansion(item, item.text(0))&#10;&#10;        return expanded_paths&#10;&#10;    def _save_selected_path(self):&#10;        &quot;&quot;&quot;Save the path to the currently selected item&quot;&quot;&quot;&#10;        selected_item = self.tree.currentItem()&#10;        if not selected_item:&#10;            return None&#10;&#10;        path = []&#10;        node = selected_item&#10;        while node:&#10;            path.insert(0, node.text(0))&#10;            node = node.parent()&#10;        return &quot;/&quot;.join(path)&#10;&#10;    def _clear_layer_children(self):&#10;        &quot;&quot;&quot;Clear all children from layer items&quot;&quot;&quot;&#10;        for layer_item in self.layers.values():&#10;            layer_item.takeChildren()&#10;&#10;    def _populate_segments(self):&#10;        &quot;&quot;&quot;Populate segments in the tree structure&quot;&quot;&quot;&#10;        segments = self.contour_editor.manager.get_segments()&#10;        print(f&quot;Segments: {segments}&quot;)&#10;&#10;        for seg_index, segment in enumerate(segments):&#10;            layer = getattr(segment, &quot;layer&quot;)&#10;            if layer is None:&#10;                continue&#10;&#10;            print(f&quot;Segment {seg_index}: Layer = {layer}&quot;)&#10;            layer_name = layer.name&#10;&#10;            parent_layer = self.layers.get(layer_name)&#10;&#10;            # Create layer dynamically if it doesn't exist&#10;            if not parent_layer:&#10;                print(f&quot;Warning: Layer '{layer_name}' not found, creating it.&quot;)&#10;                parent_layer = self._create_layer_item(layer_name)&#10;                self.layers[layer_name] = parent_layer&#10;                self.tree.addTopLevelItem(parent_layer)&#10;&#10;            # Create segment item&#10;            # seg_item = QTreeWidgetItem([f&quot;S{seg_index}&quot;, &quot;&quot;])&#10;            seg_item = QTreeWidgetItem([&quot;&quot;])&#10;            seg_item.setFlags(seg_item.flags() &amp; ~Qt.ItemFlag.ItemIsEditable)&#10;            seg_item.setFont(0, QFont(&quot;Arial&quot;, 14))&#10;            parent_layer.addChild(seg_item)&#10;            # ✅ Store seg_index in the item&#10;            seg_item.setData(0, Qt.ItemDataRole.UserRole, seg_index)&#10;&#10;            # Create segment control widgets&#10;            seg_container = self._create_segment_container(seg_item, seg_index, segment, layer_name)&#10;            self.tree.setItemWidget(seg_item, 0, seg_container)&#10;&#10;            # Add point children&#10;            self._add_anchor_and_control_points(seg_item, segment)&#10;&#10;        print(&quot;Segments populated.&quot;)&#10;&#10;    def _create_segment_container(self, seg_item, seg_index, segment, layer_name):&#10;        def on_visibility(btn):&#10;            visible = btn.isChecked()&#10;            btn.setIcon(QIcon(HIDE_ICON if visible else SHOW_ICON))&#10;            self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;            self.contour_editor.update()&#10;&#10;        def on_activate():&#10;            self.set_active_segment_ui(seg_index)&#10;&#10;        def on_delete():&#10;            self.delete_segment(seg_index)&#10;&#10;        def on_settings():&#10;            self._on_settings_button_clicked(seg_index)&#10;&#10;        def on_layer_change(new_layer_name):&#10;            self.assign_segment_layer(seg_index, new_layer_name)&#10;&#10;        return SegmentButtonsAndComboWidget(&#10;            seg_index=seg_index,&#10;            segment=segment,&#10;            layer_name=layer_name,&#10;            on_visibility=on_visibility,&#10;            on_activate=on_activate,&#10;            on_delete=on_delete,&#10;            on_settings=on_settings,&#10;            on_layer_change=on_layer_change&#10;        )&#10;&#10;    def _show_settings_dialog(self,seg_index, segment):&#10;        # Prepare input keys for the settings widget&#10;        inputKeys = [key.value for key in GlueSettingKey]&#10;        if GlueSettingKey.GLUE_TYPE.value in inputKeys:&#10;            inputKeys.remove(GlueSettingKey.GLUE_TYPE.value)&#10;&#10;        inputKeys.append(RobotSettingKey.VELOCITY.value)&#10;        inputKeys.append(RobotSettingKey.ACCELERATION.value)&#10;&#10;        comboEnums = [[GlueSettingKey.GLUE_TYPE.value, GlueType]]&#10;&#10;        # Create the settings widget&#10;        from PyQt6.QtWidgets import QDialog, QVBoxLayout&#10;&#10;        dialog = QDialog()&#10;        dialog.setWindowTitle(f&quot;Segment {seg_index} Settings&quot;)&#10;        dialog.setMinimumWidth(400)&#10;        dialog.setMinimumHeight(300)&#10;&#10;        widget = SegmentSettingsWidget(inputKeys + [GlueSettingKey.GLUE_TYPE.value], comboEnums, segment=segment,&#10;                                       parent=dialog)&#10;        layout = QVBoxLayout(dialog)&#10;        layout.addWidget(widget)&#10;        dialog.setLayout(layout)&#10;&#10;        dialog.exec()  # This will keep the dialog open until closed explicitly&#10;&#10;    def _on_settings_button_clicked(self, seg_index):&#10;        segment = self.contour_editor.manager.get_segments()[seg_index]&#10;        layer = getattr(segment, &quot;layer&quot;, None)&#10;        layer_name = layer.name if layer else &quot;Unknown&quot;&#10;        print(f&quot;Settings button clicked for segment {seg_index} (Layer: {layer_name})&quot;)&#10;        self._show_settings_dialog(seg_index,segment)&#10;&#10;&#10;&#10;    def _add_anchor_and_control_points(self, seg_item, segment):&#10;        &quot;&quot;&quot;Add anchor and control points as children of the segment item&quot;&quot;&quot;&#10;        # Add anchor points&#10;        for i, pt in enumerate(segment.points):&#10;            coords = f&quot;({pt.x():.1f}, {pt.y():.1f})&quot; if isinstance(pt, QPointF) else &quot;Invalid&quot;&#10;            pt_item = QTreeWidgetItem([f&quot;P{i}&quot;, coords])&#10;            pt_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            pt_item.setForeground(0, QColor(&quot;#0066cc&quot;))&#10;            seg_item.addChild(pt_item)&#10;&#10;        # Add control points&#10;        for i, ctrl in enumerate(segment.controls):&#10;            coords = f&quot;({ctrl.x():.1f}, {ctrl.y():.1f})&quot; if isinstance(ctrl, QPointF) else &quot;Invalid&quot;&#10;            ctrl_item = QTreeWidgetItem([f&quot;C{i}&quot;, coords])&#10;            ctrl_item.setFont(0, QFont(&quot;Arial&quot;, 12))&#10;            ctrl_item.setForeground(0, QColor(&quot;#cc6600&quot;))&#10;            seg_item.addChild(ctrl_item)&#10;&#10;    def _restore_expanded_state(self, expanded_paths):&#10;        &quot;&quot;&quot;Restore the expanded state of tree items&quot;&quot;&quot;&#10;&#10;        def restore_expansion(item, path=&quot;&quot;):&#10;            if path in expanded_paths:&#10;                item.setExpanded(True)&#10;            for i in range(item.childCount()):&#10;                child = item.child(i)&#10;                restore_expansion(child, f&quot;{path}/{child.text(0)}&quot;)&#10;&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            restore_expansion(item, item.text(0))&#10;&#10;    def _restore_selected_path(self, selected_path):&#10;        &quot;&quot;&quot;Restore the selected item based on saved path&quot;&quot;&quot;&#10;        if not selected_path:&#10;            return&#10;&#10;        def find_item_by_path(root, path_parts):&#10;            if not path_parts:&#10;                return root&#10;            for i in range(root.childCount()):&#10;                child = root.child(i)&#10;                if child.text(0) == path_parts[0]:&#10;                    return find_item_by_path(child, path_parts[1:])&#10;            return None&#10;&#10;        path_parts = selected_path.split(&quot;/&quot;)&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            item = self.tree.topLevelItem(i)&#10;            if item.text(0) == path_parts[0]:&#10;                target = find_item_by_path(item, path_parts[1:])&#10;                if target:&#10;                    self.tree.setCurrentItem(target)&#10;                    break&#10;&#10;    def set_active_segment_ui(self, seg_index):&#10;        &quot;&quot;&quot;Update UI to reflect the active segment&quot;&quot;&quot;&#10;        self.contour_editor.manager.set_active_segment(seg_index)&#10;        print(f&quot;[DEBUG] Set active segment to {seg_index}&quot;)&#10;&#10;        # Update all segment active buttons&#10;        for i in range(self.tree.topLevelItemCount()):&#10;            layer_item = self.tree.topLevelItem(i)&#10;            for j in range(layer_item.childCount()):&#10;                seg_item = layer_item.child(j)&#10;                # Use seg_item data for index checking&#10;                item_seg_index = seg_item.data(0, Qt.ItemDataRole.UserRole)&#10;                is_active = item_seg_index == seg_index&#10;&#10;                container = self.tree.itemWidget(seg_item, 1)&#10;                if container:&#10;                    buttons = container.findChildren(QPushButton)&#10;                    for btn in buttons:&#10;                        if btn.toolTip() == &quot;Set as active segment&quot;:&#10;                            print(&quot;setting active button for segment&quot;, seg_index)&#10;                            btn.setIcon(QIcon(ACTIVE_ICON if is_active else INACTIVE_ICON))&#10;&#10;        self.tree.viewport().update()&#10;        self.contour_editor.update()&#10;&#10;    def delete_segment(self, seg_index):&#10;        &quot;&quot;&quot;Delete a segment&quot;&quot;&quot;&#10;        if self.contour_editor:&#10;            print(f&quot;Deleting segment {seg_index}&quot;)&#10;            self.contour_editor.manager.delete_segment(seg_index)&#10;            self.contour_editor.update()&#10;            self.refresh_points()&#10;&#10;    def assign_segment_layer(self, seg_index, layer_name):&#10;        &quot;&quot;&quot;Assign a segment to a different layer&quot;&quot;&quot;&#10;        print(f&quot;Assigning Segment {seg_index} to layer '{layer_name}'&quot;)&#10;        if self.contour_editor:&#10;            self.contour_editor.manager.assign_segment_layer(seg_index, layer_name)&#10;            self.refresh_points()&#10;            self.contour_editor.update()&#10;&#10;    def handle_segment_toggle(self, item, column):&#10;        &quot;&quot;&quot;Handle segment toggle events&quot;&quot;&quot;&#10;        if not self.contour_editor:&#10;            return&#10;&#10;        # Layer visibility toggle&#10;        if item.parent() is None and column == 0:&#10;            layer_name = item.text(0)&#10;            visible = item.checkState(0) == Qt.CheckState.Checked&#10;            self.set_layer_visibility(layer_name, visible)&#10;            self.contour_editor.update()&#10;            return&#10;&#10;        # Segment visibility toggle&#10;        if item.parent() and column == 0:&#10;            # Use seg_item data for index checking&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    visible = item.checkState(0) == Qt.CheckState.Checked&#10;                    self.contour_editor.manager.set_segment_visibility(seg_index, visible)&#10;                    self.contour_editor.update()&#10;                except Exception as e:&#10;                    print(f&quot;[Error] segment visibility toggle: {e}&quot;)&#10;                return&#10;&#10;        # Segment activation toggle&#10;        if item.parent() and column == 2:&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                try:&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;                except Exception as e:&#10;                    print(f&quot;[Error] handle_segment_toggle: {e}&quot;)&#10;&#10;    def highlight_selected_point(self, item):&#10;        &quot;&quot;&quot;Handle point selection and highlighting&quot;&quot;&quot;&#10;        if not item or not self.contour_editor:&#10;            print(&quot;No item selected.&quot;)&#10;            return&#10;&#10;        print(f&quot;Item clicked: {item.text(0)}&quot;)&#10;&#10;        try:&#10;            # Handle segment selection&#10;            seg_index = item.data(0, Qt.ItemDataRole.UserRole)&#10;            if seg_index is not None:&#10;                self.tree.blockSignals(True)&#10;                self.set_active_segment_ui(seg_index)&#10;                self.tree.blockSignals(False)&#10;                return&#10;&#10;            # Handle point selection&#10;            parent = item.parent()&#10;            if parent:&#10;                seg_index = parent.data(0, Qt.ItemDataRole.UserRole)&#10;                label = item.text(0)&#10;&#10;                if seg_index is not None:&#10;                    if label.startswith(&quot;P&quot;):&#10;                        idx = int(label[1:])&#10;                        self.contour_editor.selected_point_info = ('anchor', seg_index, idx)&#10;                    elif label.startswith(&quot;C&quot;):&#10;                        idx = int(label[1:])&#10;                        self.contour_editor.selected_point_info = ('control', seg_index, idx)&#10;&#10;                    self.tree.blockSignals(True)&#10;                    self.set_active_segment_ui(seg_index)&#10;                    self.tree.blockSignals(False)&#10;&#10;        except Exception as e:&#10;            print(f&quot;Selection error: {e}&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from unittest.mock import MagicMock&#10;&#10;    app = QApplication(sys.argv)&#10;    mock_contour_editor = MagicMock()&#10;    mock_manager = MagicMock()&#10;    mock_contour_editor.manager = mock_manager&#10;    widget = PointManagerWidget(contour_editor=mock_contour_editor)&#10;    widget.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pl_gui/contour_editor/SegmentButtonsAndComboWidget.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/contour_editor/SegmentButtonsAndComboWidget.py" />
              <option name="originalContent" value="import os&#10;import sys&#10;from types import SimpleNamespace&#10;&#10;from PyQt6.QtCore import Qt, QSize, QTimer&#10;from PyQt6.QtGui import QIcon&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy&#10;)&#10;from PyQt6.QtCore import Qt, QSize, QTimer, QPoint  # Add QPoint&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy, QMenu, QWidgetAction  # Add QMenu, QWidgetAction&#10;)&#10;&#10;# --- Resource Paths ---&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR, &quot;dropdown_open.png&quot;)&#10;GEAR_ICON = os.path.join(RESOURCE_DIR, &quot;SETTINGS_BUTTON.png&quot;)&#10;&#10;&#10;class LayerSelectionPopup(QMenu):&#10;    &quot;&quot;&quot;Custom popup menu for layer selection&quot;&quot;&quot;&#10;&#10;    def __init__(self, current_layer, on_layer_change, parent=None):&#10;        super().__init__(parent)&#10;        self.on_layer_change = on_layer_change&#10;        self.current_layer = current_layer&#10;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QMenu {&#10;                background-color: white;&#10;                border: 2px solid #007acc;&#10;                border-radius: 8px;&#10;                padding: 5px;&#10;                font-size: 14px;&#10;            }&#10;            QMenu::item {&#10;                padding: 8px 20px;&#10;                margin: 2px;&#10;                border-radius: 4px;&#10;            }&#10;            QMenu::item:selected {&#10;                background-color: #e6f3ff;&#10;                color: #007acc;&#10;            }&#10;            QMenu::item:pressed {&#10;                background-color: #cce7ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Add layer options&#10;        layers = [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]&#10;        for layer in layers:&#10;            action = self.addAction(layer)&#10;            action.triggered.connect(lambda checked, l=layer: self._on_layer_selected(l))&#10;&#10;            # Mark current layer&#10;            if layer == current_layer:&#10;                action.setText(f&quot;✓ {layer}&quot;)&#10;                action.setStyleSheet(&quot;font-weight: bold; color: #007acc;&quot;)&#10;&#10;    def _on_layer_selected(self, layer):&#10;        if self.on_layer_change:&#10;            self.on_layer_change(layer)&#10;&#10;class PressAndHoldButton(QPushButton):&#10;    &quot;&quot;&quot;Custom button that supports press and hold functionality&quot;&quot;&quot;&#10;&#10;    def __init__(self, text=&quot;&quot;, parent=None):&#10;        super().__init__(text, parent)&#10;&#10;        self.press_timer = QTimer()&#10;        self.press_timer.timeout.connect(self._on_long_press)&#10;        self.press_timer.setSingleShot(True)&#10;        self.long_press_duration = 500  # milliseconds&#10;        self.is_long_press = False&#10;&#10;        # Callbacks&#10;        self.on_click_callback = None&#10;        self.on_long_press_callback = None&#10;&#10;    def set_click_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for normal click&quot;&quot;&quot;&#10;        self.on_click_callback = callback&#10;&#10;    def set_long_press_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for long press&quot;&quot;&quot;&#10;        self.on_long_press_callback = callback&#10;&#10;    def mousePressEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.is_long_press = False&#10;            self.press_timer.start(self.long_press_duration)&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.press_timer.stop()&#10;&#10;            if not self.is_long_press:&#10;                # Normal click&#10;                if self.on_click_callback:&#10;                    self.on_click_callback()&#10;&#10;        super().mouseReleaseEvent(event)&#10;&#10;    def _on_long_press(self):&#10;        &quot;&quot;&quot;Handle long press event&quot;&quot;&quot;&#10;        self.is_long_press = True&#10;        if self.on_long_press_callback:&#10;            self.on_long_press_callback()&#10;&#10;class SegmentButtonsAndComboWidget(QWidget):&#10;    def __init__(self, seg_index, segment, layer_name,&#10;                 on_visibility, on_activate, on_delete, on_settings, on_layer_change,on_long_press):&#10;        super().__init__()&#10;&#10;        self.segment = segment&#10;        self.on_visibility = on_visibility&#10;        self.on_layer_change = on_layer_change&#10;        self.seg_index = seg_index&#10;        self.current_layer = layer_name&#10;&#10;        layout = QHBoxLayout(self)&#10;        layout.setContentsMargins(0, 0, 0, 0)&#10;        layout.setSpacing(8)&#10;        layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;&#10;        # Use custom press and hold button for index label&#10;        self.index_label = PressAndHoldButton(f&quot;S{seg_index}&quot;)&#10;        self.index_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)&#10;        self.index_label.setFixedHeight(50)&#10;        self.index_label.setFixedWidth(50)&#10;        self.index_label.setToolTip(&#10;            f&quot;Segment {seg_index} - Click to activate, Hold for layer options&quot;)  # Updated tooltip&#10;        self.index_label.setStyleSheet(&quot;text-align: center;&quot;)&#10;&#10;        # Set callbacks for press and hold&#10;        self.index_label.set_click_callback(on_activate)&#10;        self.index_label.set_long_press_callback(self._show_layer_popup)  # Changed this line&#10;&#10;        layout.addWidget(self.index_label)&#10;&#10;        # Buttons&#10;        self.visibility_btn = self._create_visibility_button()&#10;        layout.addWidget(self.visibility_btn)&#10;&#10;        # self.on_activate = on_activate&#10;        self.active_btn = self._create_icon_button(&#10;            ACTIVE_ICON if getattr(segment, &quot;is_active&quot;, False) else INACTIVE_ICON,&#10;            &quot;Set as active segment&quot;,&#10;            on_activate&#10;        )&#10;        # layout.addWidget(self.active_btn)&#10;&#10;        self.delete_btn = self._create_icon_button(&#10;            BIN_ICON, &quot;Delete this segment&quot;, on_delete&#10;        )&#10;        layout.addWidget(self.delete_btn)&#10;&#10;        # Updated settings button with gear icon&#10;        self.settings_btn = self._create_icon_button(&#10;            GEAR_ICON, &quot;Segment settings&quot;, on_settings&#10;        )&#10;        layout.addWidget(self.settings_btn)&#10;&#10;        # # Combo Box for Layer Selection&#10;        # self.combo_box = QComboBox()&#10;        # self.combo_box.addItems([&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;])&#10;        # self.combo_box.setCurrentText(layer_name)&#10;        # self.combo_box.setFixedHeight(50)&#10;        # self.combo_box.setMinimumWidth(100)&#10;        # self.combo_box.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)&#10;        # self.combo_box.currentTextChanged.connect(on_layer_change)&#10;        # layout.addWidget(self.combo_box)&#10;&#10;        layout.addStretch()&#10;&#10;    def _show_layer_popup(self):&#10;        &quot;&quot;&quot;Show layer selection popup on long press&quot;&quot;&quot;&#10;        popup = LayerSelectionPopup(&#10;            current_layer=self.current_layer,&#10;            on_layer_change=self._handle_layer_change,&#10;            parent=self&#10;        )&#10;&#10;        # Position popup near the button&#10;        button_pos = self.index_label.mapToGlobal(QPoint(0, 0))&#10;        popup_pos = QPoint(button_pos.x(), button_pos.y() + self.index_label.height() + 5)&#10;        popup.exec(popup_pos)&#10;&#10;    def _handle_layer_change(self, new_layer):&#10;        &quot;&quot;&quot;Handle layer change from popup&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;        if self.on_layer_change:&#10;            self.on_layer_change(new_layer)&#10;        print(f&quot;Layer changed to: {new_layer}&quot;)&#10;&#10;    def update_layer(self, new_layer):&#10;        &quot;&quot;&quot;Update the current layer (call this from parent when layer changes)&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;&#10;    def _create_icon_button(self, icon_path, tooltip, callback):&#10;        button = QPushButton()&#10;        button.setIcon(QIcon(icon_path))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(tooltip)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(callback)&#10;        return button&#10;&#10;    def _create_visibility_button(self):&#10;        button = QPushButton()&#10;        button.setCheckable(True)&#10;        is_visible = getattr(self.segment, &quot;visible&quot;, True)&#10;        button.setChecked(is_visible)&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(&quot;Toggle segment visibility&quot;)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(lambda: self._toggle_visibility(button))&#10;        return button&#10;&#10;    def _toggle_visibility(self, button):&#10;        is_visible = button.isChecked()&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        self.on_visibility(button)&#10;&#10;&#10;# --- Testing ---&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;&#10;    segment = SimpleNamespace(visible=True, is_active=False)&#10;    layer_name = &quot;Contour&quot;&#10;&#10;&#10;    def on_visibility(btn):&#10;        print(&quot;Visibility toggled:&quot;, btn.isChecked())&#10;&#10;&#10;    def on_activate():&#10;        print(&quot;Activated&quot;)&#10;&#10;&#10;    def on_delete():&#10;        print(&quot;Deleted&quot;)&#10;&#10;&#10;    def on_settings():&#10;        print(&quot;Settings opened&quot;)&#10;&#10;&#10;    def on_layer_change(value):&#10;        print(&quot;Layer changed to:&quot;, value)&#10;&#10;&#10;    def on_long_press(seg_index):&#10;        print(f&quot;Long press detected on segment {seg_index}!&quot;)&#10;&#10;&#10;    widget = SegmentButtonsAndComboWidget(&#10;        seg_index=0,&#10;        segment=segment,&#10;        layer_name=layer_name,&#10;        on_visibility=on_visibility,&#10;        on_activate=on_activate,&#10;        on_delete=on_delete,&#10;        on_settings=on_settings,&#10;        on_layer_change=on_layer_change,&#10;        on_long_press=on_long_press&#10;    )&#10;    widget.show()&#10;    sys.exit(app.exec())&#10;" />
              <option name="updatedContent" value="import os&#10;import sys&#10;from types import SimpleNamespace&#10;&#10;from PyQt6.QtCore import Qt, QSize, QTimer&#10;from PyQt6.QtGui import QIcon&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy&#10;)&#10;from PyQt6.QtCore import Qt, QSize, QTimer, QPoint  # Add QPoint&#10;from PyQt6.QtWidgets import (&#10;    QApplication, QWidget, QHBoxLayout,&#10;    QPushButton, QComboBox, QSizePolicy, QMenu, QWidgetAction  # Add QMenu, QWidgetAction&#10;)&#10;&#10;# --- Resource Paths ---&#10;RESOURCE_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;icons&quot;)&#10;HIDE_ICON = os.path.join(RESOURCE_DIR, &quot;hide.png&quot;)&#10;SHOW_ICON = os.path.join(RESOURCE_DIR, &quot;show.png&quot;)&#10;BIN_ICON = os.path.join(RESOURCE_DIR, &quot;BIN_BUTTON_SQUARE.png&quot;)&#10;PLUS_ICON = os.path.join(RESOURCE_DIR, &quot;PLUS_BUTTON.png&quot;)&#10;LOCK_ICON = os.path.join(RESOURCE_DIR, &quot;locked.png&quot;)&#10;UNLOCK_ICON = os.path.join(RESOURCE_DIR, &quot;unlocked.png&quot;)&#10;ACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;active.png&quot;)&#10;INACTIVE_ICON = os.path.join(RESOURCE_DIR, &quot;inactive.png&quot;)&#10;DROPDOWN_OPEN_ICON = os.path.join(RESOURCE_DIR, &quot;dropdown_open.png&quot;)&#10;GEAR_ICON = os.path.join(RESOURCE_DIR, &quot;SETTINGS_BUTTON.png&quot;)&#10;&#10;&#10;class LayerSelectionPopup(QMenu):&#10;    &quot;&quot;&quot;Custom popup menu for layer selection&quot;&quot;&quot;&#10;&#10;    def __init__(self, current_layer, on_layer_change, parent=None):&#10;        super().__init__(parent)&#10;        self.on_layer_change = on_layer_change&#10;        self.current_layer = current_layer&#10;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QMenu {&#10;                background-color: white;&#10;                border: 2px solid #007acc;&#10;                border-radius: 8px;&#10;                padding: 5px;&#10;                font-size: 14px;&#10;            }&#10;            QMenu::item {&#10;                padding: 8px 20px;&#10;                margin: 2px;&#10;                border-radius: 4px;&#10;            }&#10;            QMenu::item:selected {&#10;                background-color: #e6f3ff;&#10;                color: #007acc;&#10;            }&#10;            QMenu::item:pressed {&#10;                background-color: #cce7ff;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Add layer options&#10;        layers = [&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;]&#10;        for layer in layers:&#10;            action = self.addAction(layer)&#10;            action.triggered.connect(lambda checked, l=layer: self._on_layer_selected(l))&#10;&#10;            # Mark current layer&#10;            if layer == current_layer:&#10;                action.setText(f&quot;✓ {layer}&quot;)&#10;&#10;    def _on_layer_selected(self, layer):&#10;        if self.on_layer_change:&#10;            self.on_layer_change(layer)&#10;&#10;class PressAndHoldButton(QPushButton):&#10;    &quot;&quot;&quot;Custom button that supports press and hold functionality&quot;&quot;&quot;&#10;&#10;    def __init__(self, text=&quot;&quot;, parent=None):&#10;        super().__init__(text, parent)&#10;&#10;        self.press_timer = QTimer()&#10;        self.press_timer.timeout.connect(self._on_long_press)&#10;        self.press_timer.setSingleShot(True)&#10;        self.long_press_duration = 500  # milliseconds&#10;        self.is_long_press = False&#10;&#10;        # Callbacks&#10;        self.on_click_callback = None&#10;        self.on_long_press_callback = None&#10;&#10;    def set_click_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for normal click&quot;&quot;&quot;&#10;        self.on_click_callback = callback&#10;&#10;    def set_long_press_callback(self, callback):&#10;        &quot;&quot;&quot;Set callback for long press&quot;&quot;&quot;&#10;        self.on_long_press_callback = callback&#10;&#10;    def mousePressEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.is_long_press = False&#10;            self.press_timer.start(self.long_press_duration)&#10;        super().mousePressEvent(event)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.press_timer.stop()&#10;&#10;            if not self.is_long_press:&#10;                # Normal click&#10;                if self.on_click_callback:&#10;                    self.on_click_callback()&#10;&#10;        super().mouseReleaseEvent(event)&#10;&#10;    def _on_long_press(self):&#10;        &quot;&quot;&quot;Handle long press event&quot;&quot;&quot;&#10;        self.is_long_press = True&#10;        if self.on_long_press_callback:&#10;            self.on_long_press_callback()&#10;&#10;class SegmentButtonsAndComboWidget(QWidget):&#10;    def __init__(self, seg_index, segment, layer_name,&#10;                 on_visibility, on_activate, on_delete, on_settings, on_layer_change,on_long_press):&#10;        super().__init__()&#10;&#10;        self.segment = segment&#10;        self.on_visibility = on_visibility&#10;        self.on_layer_change = on_layer_change&#10;        self.seg_index = seg_index&#10;        self.current_layer = layer_name&#10;&#10;        layout = QHBoxLayout(self)&#10;        layout.setContentsMargins(0, 0, 0, 0)&#10;        layout.setSpacing(8)&#10;        layout.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)&#10;&#10;        # Use custom press and hold button for index label&#10;        self.index_label = PressAndHoldButton(f&quot;S{seg_index}&quot;)&#10;        self.index_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)&#10;        self.index_label.setFixedHeight(50)&#10;        self.index_label.setFixedWidth(50)&#10;        self.index_label.setToolTip(&#10;            f&quot;Segment {seg_index} - Click to activate, Hold for layer options&quot;)  # Updated tooltip&#10;        self.index_label.setStyleSheet(&quot;text-align: center;&quot;)&#10;&#10;        # Set callbacks for press and hold&#10;        self.index_label.set_click_callback(on_activate)&#10;        self.index_label.set_long_press_callback(self._show_layer_popup)  # Changed this line&#10;&#10;        layout.addWidget(self.index_label)&#10;&#10;        # Buttons&#10;        self.visibility_btn = self._create_visibility_button()&#10;        layout.addWidget(self.visibility_btn)&#10;&#10;        # self.on_activate = on_activate&#10;        self.active_btn = self._create_icon_button(&#10;            ACTIVE_ICON if getattr(segment, &quot;is_active&quot;, False) else INACTIVE_ICON,&#10;            &quot;Set as active segment&quot;,&#10;            on_activate&#10;        )&#10;        # layout.addWidget(self.active_btn)&#10;&#10;        self.delete_btn = self._create_icon_button(&#10;            BIN_ICON, &quot;Delete this segment&quot;, on_delete&#10;        )&#10;        layout.addWidget(self.delete_btn)&#10;&#10;        # Updated settings button with gear icon&#10;        self.settings_btn = self._create_icon_button(&#10;            GEAR_ICON, &quot;Segment settings&quot;, on_settings&#10;        )&#10;        layout.addWidget(self.settings_btn)&#10;&#10;        # # Combo Box for Layer Selection&#10;        # self.combo_box = QComboBox()&#10;        # self.combo_box.addItems([&quot;External&quot;, &quot;Contour&quot;, &quot;Fill&quot;])&#10;        # self.combo_box.setCurrentText(layer_name)&#10;        # self.combo_box.setFixedHeight(50)&#10;        # self.combo_box.setMinimumWidth(100)&#10;        # self.combo_box.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)&#10;        # self.combo_box.currentTextChanged.connect(on_layer_change)&#10;        # layout.addWidget(self.combo_box)&#10;&#10;        layout.addStretch()&#10;&#10;    def _show_layer_popup(self):&#10;        &quot;&quot;&quot;Show layer selection popup on long press&quot;&quot;&quot;&#10;        popup = LayerSelectionPopup(&#10;            current_layer=self.current_layer,&#10;            on_layer_change=self._handle_layer_change,&#10;            parent=self&#10;        )&#10;&#10;        # Position popup near the button&#10;        button_pos = self.index_label.mapToGlobal(QPoint(0, 0))&#10;        popup_pos = QPoint(button_pos.x(), button_pos.y() + self.index_label.height() + 5)&#10;        popup.exec(popup_pos)&#10;&#10;    def _handle_layer_change(self, new_layer):&#10;        &quot;&quot;&quot;Handle layer change from popup&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;        if self.on_layer_change:&#10;            self.on_layer_change(new_layer)&#10;        print(f&quot;Layer changed to: {new_layer}&quot;)&#10;&#10;    def update_layer(self, new_layer):&#10;        &quot;&quot;&quot;Update the current layer (call this from parent when layer changes)&quot;&quot;&quot;&#10;        self.current_layer = new_layer&#10;&#10;    def _create_icon_button(self, icon_path, tooltip, callback):&#10;        button = QPushButton()&#10;        button.setIcon(QIcon(icon_path))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(tooltip)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(callback)&#10;        return button&#10;&#10;    def _create_visibility_button(self):&#10;        button = QPushButton()&#10;        button.setCheckable(True)&#10;        is_visible = getattr(self.segment, &quot;visible&quot;, True)&#10;        button.setChecked(is_visible)&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        button.setIconSize(QSize(50, 50))&#10;        button.setToolTip(&quot;Toggle segment visibility&quot;)&#10;        button.setFixedSize(80, 80)&#10;        button.clicked.connect(lambda: self._toggle_visibility(button))&#10;        return button&#10;&#10;    def _toggle_visibility(self, button):&#10;        is_visible = button.isChecked()&#10;        button.setIcon(QIcon(HIDE_ICON if is_visible else SHOW_ICON))&#10;        self.on_visibility(button)&#10;&#10;&#10;# --- Testing ---&#10;if __name__ == &quot;__main__&quot;:&#10;    app = QApplication(sys.argv)&#10;&#10;    segment = SimpleNamespace(visible=True, is_active=False)&#10;    layer_name = &quot;Contour&quot;&#10;&#10;&#10;    def on_visibility(btn):&#10;        print(&quot;Visibility toggled:&quot;, btn.isChecked())&#10;&#10;&#10;    def on_activate():&#10;        print(&quot;Activated&quot;)&#10;&#10;&#10;    def on_delete():&#10;        print(&quot;Deleted&quot;)&#10;&#10;&#10;    def on_settings():&#10;        print(&quot;Settings opened&quot;)&#10;&#10;&#10;    def on_layer_change(value):&#10;        print(&quot;Layer changed to:&quot;, value)&#10;&#10;&#10;    def on_long_press(seg_index):&#10;        print(f&quot;Long press detected on segment {seg_index}!&quot;)&#10;&#10;&#10;    widget = SegmentButtonsAndComboWidget(&#10;        seg_index=0,&#10;        segment=segment,&#10;        layer_name=layer_name,&#10;        on_visibility=on_visibility,&#10;        on_activate=on_activate,&#10;        on_delete=on_delete,&#10;        on_settings=on_settings,&#10;        on_layer_change=on_layer_change,&#10;        on_long_press=on_long_press&#10;    )&#10;    widget.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pl_gui/main_application/ExpandedFolderView.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/main_application/ExpandedFolderView.py" />
              <option name="originalContent" value="import os&#10;from PyQt6.QtCore import Qt, pyqtSignal, QPropertyAnimation, QEasingCurve, QRect, QTimer, QParallelAnimationGroup, \&#10;    QPoint&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, QToolButton, QPushButton, QFrame, QScrollArea,&#10;    QGraphicsDropShadowEffect&#10;)&#10;from PyQt6.QtGui import QFont, QColor, QPixmap, QPalette, QIcon&#10;&#10;from pl_gui.main_application.FloatingFolderIcon import FloatingFolderIcon&#10;from pl_gui.main_application.MenuIcon import MenuIcon&#10;from PyQt6.QtWidgets import QPushButton&#10;from PyQt6.QtCore import QSize&#10;&#10;&#10;&#10;&#10;class ExpandedFolderView(QFrame):&#10;    &quot;&quot;&quot;Material Design 3 expanded folder view with modern animations&quot;&quot;&quot;&#10;&#10;    close_requested = pyqtSignal()&#10;    app_selected = pyqtSignal(str)&#10;&#10;    close_current_app_requested = pyqtSignal()&#10;&#10;    def __init__(self, folder_ref, parent=None):&#10;        super().__init__(parent)&#10;        self.setObjectName(&quot;ExpandedFolderView&quot;)&#10;        self.folder_ref = folder_ref&#10;        self.setFixedSize(580, 680)  # Material Design proportions&#10;        self._is_closing = False&#10;        self._is_transitioning = False&#10;        self._is_hidden_mode = False&#10;        self._current_app_name = None&#10;&#10;        self.floating_icon = None&#10;        self.close_app_button = None&#10;&#10;        self.setup_ui()&#10;        self.setup_smooth_animations()&#10;&#10;    def close_from_outside(self):&#10;        &quot;&quot;&quot;Handle close request from outside (clicking outside the folder)&quot;&quot;&quot;&#10;        if self._current_app_name:&#10;            # If app is running, don't remove floating icon, just hide expanded view&#10;            if not self._is_hidden_mode:&#10;                self.hide_and_show_floating_icon()&#10;        else:&#10;            # No app running, normal close behavior&#10;            self.safe_close()&#10;    def setup_smooth_animations(self):&#10;        &quot;&quot;&quot;Material Design animation system&quot;&quot;&quot;&#10;        self.opacity_animation = QPropertyAnimation(self, b&quot;windowOpacity&quot;)&#10;        self.opacity_animation.setDuration(300)  # Material standard duration&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.scale_animation = QPropertyAnimation(self, b&quot;geometry&quot;)&#10;        self.scale_animation.setDuration(300)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.anim_group = QParallelAnimationGroup(self)&#10;        self.anim_group.addAnimation(self.opacity_animation)&#10;        self.anim_group.addAnimation(self.scale_animation)&#10;        self.anim_group.finished.connect(self.animation_finished)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Material Design 3 surface styling&quot;&quot;&quot;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QFrame {&#10;                background: #FFFBFE;&#10;                border: 1px solid #E7E0EC;&#10;                border-radius: 28px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Material Design elevation shadow&#10;        try:&#10;            shadow = QGraphicsDropShadowEffect()&#10;            shadow.setBlurRadius(32)&#10;            shadow.setColor(QColor(0, 0, 0, 30))  # Material elevation 3&#10;            shadow.setOffset(0, 6)&#10;            self.setGraphicsEffect(shadow)&#10;        except:&#10;            pass&#10;&#10;        # Material Design layout with proper spacing&#10;        main_layout = QVBoxLayout(self)&#10;        main_layout.setSpacing(24)  # Material Design spacing&#10;        main_layout.setContentsMargins(24, 24, 24, 24)&#10;&#10;        # Header with Material Design typography&#10;        header_layout = QHBoxLayout()&#10;&#10;        # Material Design headline typography&#10;        self.title_label = QLabel(self.folder_ref.folder_name)&#10;        self.title_label.setObjectName(&quot;FolderTitle&quot;)&#10;        self.title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;&#10;        # Material Design typography&#10;        try:&#10;            font = QFont(&quot;Roboto&quot;, 28, QFont.Weight.Medium)&#10;            if not font.exactMatch():&#10;                font = QFont(&quot;Segoe UI&quot;, 28, QFont.Weight.Medium)&#10;            self.title_label.setFont(font)&#10;        except:&#10;            pass&#10;&#10;        self.title_label.setStyleSheet(&quot;&quot;&quot;&#10;            QLabel {&#10;                color: #1D1B20;&#10;                background-color: transparent;&#10;                padding-bottom: 8px;&#10;                font-weight: 500;&#10;                letter-spacing: 0px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Material Design filled button for close app&#10;        self.close_app_button = QPushButton(&quot;Close App&quot;)&#10;        self.close_app_button.setFixedSize(140, 40)&#10;        self.close_app_button.setStyleSheet(&quot;&quot;&quot;&#10;            QPushButton {&#10;                background: #6750A4;&#10;                border: none;&#10;                border-radius: 20px;&#10;                color: white;&#10;                font-size: 14px;&#10;                font-weight: 500;&#10;                font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;                padding: 10px 24px;&#10;            }&#10;            QPushButton:hover {&#10;                background: #7965AF;&#10;            }&#10;            QPushButton:pressed {&#10;                background: #5A3D99;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.close_app_button.clicked.connect(self.on_close_app_clicked)&#10;        self.close_app_button.hide()&#10;&#10;        # Material Design button shadow&#10;        try:&#10;            close_button_shadow = QGraphicsDropShadowEffect()&#10;            close_button_shadow.setBlurRadius(8)&#10;            close_button_shadow.setColor(QColor(0, 0, 0, 40))&#10;            close_button_shadow.setOffset(0, 2)&#10;            self.close_app_button.setGraphicsEffect(close_button_shadow)&#10;        except:&#10;            pass&#10;&#10;        header_layout.addStretch(1)&#10;        header_layout.addWidget(self.title_label, 2)&#10;        header_layout.addWidget(self.close_app_button, 0, Qt.AlignmentFlag.AlignRight)&#10;&#10;        main_layout.addLayout(header_layout)&#10;&#10;        # Material Design scroll area&#10;        self.scroll_area = QScrollArea()&#10;        self.scroll_area.setObjectName(&quot;ExpandedScrollArea&quot;)&#10;        self.scroll_area.setWidgetResizable(True)&#10;        self.scroll_area.setStyleSheet(&quot;&quot;&quot;&#10;            QScrollArea { &#10;                border: none; &#10;                background: transparent; &#10;            }&#10;            QScrollBar:vertical {&#10;                background-color: #F7F2FA;&#10;                width: 12px;&#10;                border-radius: 6px;&#10;                margin: 2px;&#10;            }&#10;            QScrollBar::handle:vertical {&#10;                background-color: #CAC4D0;&#10;                border-radius: 6px;&#10;                min-height: 30px;&#10;            }&#10;            QScrollBar::handle:vertical:hover {&#10;                background-color: #79747E;&#10;            }&#10;            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {&#10;                border: none;&#10;                background: none;&#10;                height: 0px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        grid_widget = QWidget()&#10;        grid_widget.setStyleSheet(&quot;background-color: transparent;&quot;)&#10;        self.grid_layout = QGridLayout(grid_widget)&#10;        self.grid_layout.setSpacing(16)  # Material Design grid spacing&#10;        self.grid_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)&#10;        self.grid_layout.setContentsMargins(8, 8, 8, 8)&#10;        self.scroll_area.setWidget(grid_widget)&#10;        main_layout.addWidget(self.scroll_area)&#10;&#10;        self.update_apps()&#10;&#10;    def safe_close(self):&#10;        &quot;&quot;&quot;Material Design close transition&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;&#10;        if self._is_hidden_mode and self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;            QTimer.singleShot(200, self._complete_close)&#10;        else:&#10;            self._is_closing = True&#10;            self.fade_out()&#10;&#10;    def _complete_close(self):&#10;        &quot;&quot;&quot;Complete the Material Design close sequence&quot;&quot;&quot;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;        self._is_closing = True&#10;        self.close_requested.emit()&#10;&#10;    def fade_in(self, center_pos):&#10;        &quot;&quot;&quot;Material Design scale-in animation&quot;&quot;&quot;&#10;        print(f&quot;Material fade_in called with center_pos: {center_pos}&quot;)&#10;&#10;        self.anim_group.stop()&#10;&#10;        final_x = int(center_pos.x() - self.width() // 2)&#10;        final_y = int(center_pos.y() - self.height() // 2)&#10;&#10;        # Material Design scale factor&#10;        scale_factor = 0.8&#10;        start_width = int(self.width() * scale_factor)&#10;        start_height = int(self.height() * scale_factor)&#10;        start_x = int(center_pos.x() - start_width // 2)&#10;        start_y = int(center_pos.y() - start_height // 2)&#10;&#10;        self.setGeometry(start_x, start_y, start_width, start_height)&#10;        self.setWindowOpacity(0.0)&#10;        self.show()&#10;        self.raise_()&#10;&#10;        # Material Design animation curves&#10;        self.opacity_animation.setStartValue(0.0)&#10;        self.opacity_animation.setEndValue(1.0)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        start_rect = QRect(start_x, start_y, start_width, start_height)&#10;        final_rect = QRect(final_x, final_y, self.width(), self.height())&#10;        self.scale_animation.setStartValue(start_rect)&#10;        self.scale_animation.setEndValue(final_rect)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.anim_group.start()&#10;&#10;    def fade_out(self):&#10;        &quot;&quot;&quot;Material Design scale-out animation&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;        self._is_closing = True&#10;&#10;        self.anim_group.stop()&#10;&#10;        current_rect = self.geometry()&#10;        center_x, center_y = current_rect.center().x(), current_rect.center().y()&#10;&#10;        scale_factor = 0.8&#10;        end_width = int(self.width() * scale_factor)&#10;        end_height = int(self.height() * scale_factor)&#10;        end_x = int(center_x - end_width // 2)&#10;        end_y = int(center_y - end_height // 2)&#10;&#10;        self.opacity_animation.setStartValue(1.0)&#10;        self.opacity_animation.setEndValue(0.0)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.InCubic)&#10;&#10;        end_rect = QRect(end_x, end_y, end_width, end_height)&#10;        self.scale_animation.setStartValue(current_rect)&#10;        self.scale_animation.setEndValue(end_rect)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.InCubic)&#10;&#10;        self.anim_group.start()&#10;&#10;    def hide_and_show_floating_icon(self):&#10;        &quot;&quot;&quot;Material Design transition to floating action button&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;&#10;        print(&quot;Material Design transition to FAB&quot;)&#10;        self._is_transitioning = True&#10;        self._is_hidden_mode = True&#10;&#10;        main_window = self.parent()&#10;        while main_window and main_window.parent():&#10;            main_window = main_window.parent()&#10;        parent = main_window&#10;&#10;        # Material Design floating action button&#10;        self.floating_icon = FloatingFolderIcon(self.folder_ref.folder_name, parent)&#10;        self.position_floating_icon()&#10;        self.floating_icon.clicked_signal.connect(self.restore_from_floating_icon)&#10;&#10;        self.hide()&#10;        self.setWindowOpacity(0.0)&#10;&#10;        QTimer.singleShot(50, self.floating_icon.show_with_animation)&#10;        QTimer.singleShot(300, lambda: setattr(self, '_is_transitioning', False))&#10;&#10;        # Material Design scrim update&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            self.folder_ref.overlay.disable_overlay_close = True&#10;            self.folder_ref.overlay.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.05);&quot;)&#10;&#10;    def position_floating_icon(self):&#10;        &quot;&quot;&quot;Position FAB according to Material Design guidelines&quot;&quot;&quot;&#10;        if not self.floating_icon or not self.floating_icon.parent():&#10;            return&#10;&#10;        parent_rect = self.floating_icon.parent().rect()&#10;        margin = 24  # Material Design FAB margin&#10;&#10;        # x = margin&#10;        # y = parent_rect.height() - self.floating_icon.height() - margin&#10;        x = 10&#10;        y = 10&#10;&#10;        self.floating_icon.move(x, y)&#10;&#10;    def restore_from_floating_icon(self):&#10;        &quot;&quot;&quot;Material Design restoration from FAB&quot;&quot;&quot;&#10;        print(&quot;Material Design FAB clicked - restoring&quot;)&#10;&#10;        if self._is_transitioning:&#10;            return&#10;&#10;        self._is_transitioning = True&#10;        self._is_hidden_mode = False&#10;&#10;        if self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;&#10;        # Restore Material Design scrim&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            self.folder_ref.overlay.disable_overlay_close = False&#10;            self.folder_ref.overlay.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.32);&quot;)  # Material scrim&#10;            self.folder_ref.overlay.show()&#10;            self.folder_ref.overlay.raise_()&#10;&#10;        main_window = None&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            main_window = self.folder_ref.overlay.parent()&#10;&#10;        if not main_window:&#10;            main_window = self.floating_icon.parent() if self.floating_icon else None&#10;            while main_window and main_window.parent():&#10;                main_window = main_window.parent()&#10;&#10;        if main_window:&#10;            if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;                self.setParent(self.folder_ref.overlay)&#10;&#10;            center_pos = main_window.rect().center()&#10;            QTimer.singleShot(100, lambda: self.fade_in(center_pos))&#10;&#10;            if self._current_app_name:&#10;                QTimer.singleShot(400, self.show_close_app_button)&#10;&#10;        QTimer.singleShot(300, self._cleanup_floating_icon)&#10;        QTimer.singleShot(500, lambda: setattr(self, '_is_transitioning', False))&#10;&#10;    def _cleanup_floating_icon(self):&#10;        &quot;&quot;&quot;Clean up floating action button&quot;&quot;&quot;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;    def update_apps(self):&#10;        &quot;&quot;&quot;Update app grid with Material Design styling&quot;&quot;&quot;&#10;        while self.grid_layout.count():&#10;            item = self.grid_layout.takeAt(0)&#10;            if item and item.widget():&#10;                item.widget().setParent(None)&#10;                item.widget().deleteLater()&#10;&#10;        cols = 4&#10;        if hasattr(self.folder_ref, 'buttons'):&#10;            for i, button in enumerate(self.folder_ref.buttons):&#10;                row, col = divmod(i, cols)&#10;                button_copy = MenuIcon(button.icon_label, button.icon_path, button.icon_text, button.callback)&#10;                button_copy.button_clicked.connect(self.on_app_clicked)&#10;                self.grid_layout.addWidget(button_copy, row, col)&#10;&#10;    def on_app_clicked(self, app_name):&#10;        &quot;&quot;&quot;Handle app selection with Material Design feedback&quot;&quot;&quot;&#10;        print(f&quot;Material Design app selected: {app_name}&quot;)&#10;        self._current_app_name = app_name&#10;        self.app_selected.emit(app_name)&#10;        self.show_close_app_button()&#10;        self.hide_and_show_floating_icon()&#10;&#10;    def show_close_app_button(self):&#10;        &quot;&quot;&quot;Material Design button reveal animation&quot;&quot;&quot;&#10;        if self.close_app_button and self._current_app_name:&#10;            self.close_app_button.setText(f&quot;BACK&quot;)&#10;            self.close_app_button.show()&#10;&#10;            # Material Design fade-in&#10;            self.close_app_button.setWindowOpacity(0.0)&#10;            button_animation = QPropertyAnimation(self.close_app_button, b&quot;windowOpacity&quot;)&#10;            button_animation.setDuration(200)&#10;            button_animation.setStartValue(0.0)&#10;            button_animation.setEndValue(1.0)&#10;            button_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;            button_animation.start()&#10;&#10;    def hide_close_app_button(self):&#10;        &quot;&quot;&quot;Hide close button with Material Design transition&quot;&quot;&quot;&#10;        if self.close_app_button:&#10;            self.close_app_button.hide()&#10;        self._current_app_name = None&#10;&#10;    def on_close_app_clicked(self):&#10;        &quot;&quot;&quot;Handle close app with Material Design interaction&quot;&quot;&quot;&#10;        print(f&quot;Material Design close app: {self._current_app_name}&quot;)&#10;        self.close_current_app_requested.emit()&#10;        self.hide_close_app_button()&#10;&#10;        # When back button is pressed, fully close the folder&#10;        if self._is_hidden_mode and self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;            QTimer.singleShot(200, self._complete_close)&#10;        else:&#10;            # Not in hidden mode, trigger normal close&#10;            self.close_requested.emit()&#10;&#10;    def set_app_running_state(self, app_name=None):&#10;        &quot;&quot;&quot;Update app state with Material Design consistency&quot;&quot;&quot;&#10;        if app_name:&#10;            self._current_app_name = app_name&#10;            self.show_close_app_button()&#10;        else:&#10;            self.hide_close_app_button()&#10;&#10;    def animation_finished(self):&#10;        &quot;&quot;&quot;Material Design animation completion handler&quot;&quot;&quot;&#10;        if self._is_closing:&#10;            QTimer.singleShot(0, self.safe_hide)&#10;&#10;    def safe_hide(self):&#10;        &quot;&quot;&quot;Safe hide with Material Design cleanup&quot;&quot;&quot;&#10;        if self._is_closing:&#10;            QTimer.singleShot(0, self.hide)&#10;            if self.floating_icon:&#10;                self.floating_icon.deleteLater()&#10;                self.floating_icon = None&#10;&#10;    def mousePressEvent(self, event):&#10;        event.accept()&#10;&#10;    def closeEvent(self, event):&#10;        &quot;&quot;&quot;Material Design close event handling&quot;&quot;&quot;&#10;        self._is_closing = True&#10;        self.anim_group.stop()&#10;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;        while self.grid_layout.count():&#10;            item = self.grid_layout.takeAt(0)&#10;            if item and item.widget():&#10;                item.widget().setParent(None)&#10;                item.widget().deleteLater()&#10;        event.accept()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from PyQt6.QtWidgets import QApplication, QMainWindow, QPushButton&#10;&#10;    app = QApplication(sys.argv)&#10;&#10;    # Material Design application styling&#10;    app.setStyle('Fusion')&#10;    app.setStyleSheet(&quot;&quot;&quot;&#10;        QApplication {&#10;            font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;            background: #FFFBFE;&#10;        }&#10;    &quot;&quot;&quot;)&#10;&#10;    main_window = QMainWindow()&#10;    main_window.resize(900, 700)&#10;    main_window.setStyleSheet(&quot;&quot;&quot;&#10;        QMainWindow {&#10;            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,&#10;                stop:0 #FFFBFE,&#10;                stop:1 #F7F2FA);&#10;        }&#10;    &quot;&quot;&quot;)&#10;&#10;    folder_view = ExpandedFolderView(&#10;        folder_ref=type('Folder', (), {'folder_name': 'Material Apps', 'buttons': []}),&#10;        parent=main_window&#10;    )&#10;    folder_view.fade_in(main_window.rect().center())&#10;    main_window.setCentralWidget(folder_view)&#10;    main_window.show()&#10;&#10;    # Material Design test button&#10;    test_button = QPushButton(&quot;Test Material FAB&quot;, main_window)&#10;    test_button.setGeometry(10, 10, 200, 48)&#10;    test_button.setStyleSheet(&quot;&quot;&quot;&#10;        QPushButton {&#10;            background: #6750A4;&#10;            border: none;&#10;            border-radius: 24px;&#10;            color: white;&#10;            font-size: 14px;&#10;            font-weight: 500;&#10;            font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;        }&#10;        QPushButton:hover {&#10;            background: #7965AF;&#10;        }&#10;    &quot;&quot;&quot;)&#10;    test_button.clicked.connect(folder_view.hide_and_show_floating_icon)&#10;    test_button.show()&#10;&#10;    sys.exit(app.exec())" />
              <option name="updatedContent" value="import os&#10;from PyQt6.QtCore import Qt, pyqtSignal, QPropertyAnimation, QEasingCurve, QRect, QTimer, QParallelAnimationGroup, \&#10;    QPoint&#10;from PyQt6.QtWidgets import (&#10;    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout, QToolButton, QPushButton, QFrame, QScrollArea,&#10;    QGraphicsDropShadowEffect&#10;)&#10;from PyQt6.QtGui import QFont, QColor, QPixmap, QPalette, QIcon&#10;&#10;from pl_gui.main_application.FloatingFolderIcon import FloatingFolderIcon&#10;from pl_gui.main_application.MenuIcon import MenuIcon&#10;from PyQt6.QtWidgets import QPushButton&#10;from PyQt6.QtCore import QSize&#10;&#10;&#10;&#10;&#10;class ExpandedFolderView(QFrame):&#10;    &quot;&quot;&quot;Material Design 3 expanded folder view with modern animations&quot;&quot;&quot;&#10;&#10;    close_requested = pyqtSignal()&#10;    app_selected = pyqtSignal(str)&#10;&#10;    close_current_app_requested = pyqtSignal()&#10;&#10;    def __init__(self, folder_ref, parent=None):&#10;        super().__init__(parent)&#10;        self.setObjectName(&quot;ExpandedFolderView&quot;)&#10;        self.folder_ref = folder_ref&#10;        self.setFixedSize(580, 680)  # Material Design proportions&#10;        self._is_closing = False&#10;        self._is_transitioning = False&#10;        self._is_hidden_mode = False&#10;        self._current_app_name = None&#10;&#10;        self.floating_icon = None&#10;        self.close_app_button = None&#10;&#10;        self.setup_ui()&#10;        self.setup_smooth_animations()&#10;&#10;    def close_from_outside(self):&#10;        &quot;&quot;&quot;Handle close request from outside (clicking outside the folder)&quot;&quot;&quot;&#10;        if self._current_app_name:&#10;            # If app is running, don't remove floating icon, just hide expanded view&#10;            if not self._is_hidden_mode:&#10;                self.hide_and_show_floating_icon()&#10;        else:&#10;            # No app running, normal close behavior&#10;            self.safe_close()&#10;    def setup_smooth_animations(self):&#10;        &quot;&quot;&quot;Material Design animation system&quot;&quot;&quot;&#10;        self.opacity_animation = QPropertyAnimation(self, b&quot;windowOpacity&quot;)&#10;        self.opacity_animation.setDuration(300)  # Material standard duration&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.scale_animation = QPropertyAnimation(self, b&quot;geometry&quot;)&#10;        self.scale_animation.setDuration(300)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.anim_group = QParallelAnimationGroup(self)&#10;        self.anim_group.addAnimation(self.opacity_animation)&#10;        self.anim_group.addAnimation(self.scale_animation)&#10;        self.anim_group.finished.connect(self.animation_finished)&#10;&#10;    def setup_ui(self):&#10;        &quot;&quot;&quot;Material Design 3 surface styling&quot;&quot;&quot;&#10;        self.setStyleSheet(&quot;&quot;&quot;&#10;            QFrame {&#10;                background: #FFFBFE;&#10;                border: 1px solid #E7E0EC;&#10;                border-radius: 28px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Material Design elevation shadow&#10;        try:&#10;            shadow = QGraphicsDropShadowEffect()&#10;            shadow.setBlurRadius(32)&#10;            shadow.setColor(QColor(0, 0, 0, 30))  # Material elevation 3&#10;            shadow.setOffset(0, 6)&#10;            self.setGraphicsEffect(shadow)&#10;        except:&#10;            pass&#10;&#10;        # Material Design layout with proper spacing&#10;        main_layout = QVBoxLayout(self)&#10;        main_layout.setSpacing(24)  # Material Design spacing&#10;        main_layout.setContentsMargins(24, 24, 24, 24)&#10;&#10;        # Header with Material Design typography&#10;        header_layout = QHBoxLayout()&#10;&#10;        # Material Design headline typography&#10;        self.title_label = QLabel(self.folder_ref.folder_name)&#10;        self.title_label.setObjectName(&quot;FolderTitle&quot;)&#10;        self.title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)&#10;&#10;        # Material Design typography&#10;        try:&#10;            font = QFont(&quot;Roboto&quot;, 28, QFont.Weight.Medium)&#10;            if not font.exactMatch():&#10;                font = QFont(&quot;Segoe UI&quot;, 28, QFont.Weight.Medium)&#10;            self.title_label.setFont(font)&#10;        except:&#10;            pass&#10;&#10;        self.title_label.setStyleSheet(&quot;&quot;&quot;&#10;            QLabel {&#10;                color: #1D1B20;&#10;                background-color: transparent;&#10;                padding-bottom: 8px;&#10;                font-weight: 500;&#10;                letter-spacing: 0px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        # Material Design filled button for close app&#10;        self.close_app_button = QPushButton(&quot;Close App&quot;)&#10;        self.close_app_button.setFixedSize(140, 40)&#10;        self.close_app_button.setStyleSheet(&quot;&quot;&quot;&#10;            QPushButton {&#10;                background: #6750A4;&#10;                border: none;&#10;                border-radius: 20px;&#10;                color: white;&#10;                font-size: 14px;&#10;                font-weight: 500;&#10;                font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;                padding: 10px 24px;&#10;            }&#10;            QPushButton:hover {&#10;                background: #7965AF;&#10;            }&#10;            QPushButton:pressed {&#10;                background: #5A3D99;&#10;            }&#10;        &quot;&quot;&quot;)&#10;        self.close_app_button.clicked.connect(self.on_close_app_clicked)&#10;        self.close_app_button.hide()&#10;&#10;        # Material Design button shadow&#10;        try:&#10;            close_button_shadow = QGraphicsDropShadowEffect()&#10;            close_button_shadow.setBlurRadius(8)&#10;            close_button_shadow.setColor(QColor(0, 0, 0, 40))&#10;            close_button_shadow.setOffset(0, 2)&#10;            self.close_app_button.setGraphicsEffect(close_button_shadow)&#10;        except:&#10;            pass&#10;&#10;        header_layout.addStretch(1)&#10;        header_layout.addWidget(self.title_label, 2)&#10;        header_layout.addWidget(self.close_app_button, 0, Qt.AlignmentFlag.AlignRight)&#10;&#10;        main_layout.addLayout(header_layout)&#10;&#10;        # Material Design scroll area&#10;        self.scroll_area = QScrollArea()&#10;        self.scroll_area.setObjectName(&quot;ExpandedScrollArea&quot;)&#10;        self.scroll_area.setWidgetResizable(True)&#10;        self.scroll_area.setStyleSheet(&quot;&quot;&quot;&#10;            QScrollArea { &#10;                border: none; &#10;                background: transparent; &#10;            }&#10;            QScrollBar:vertical {&#10;                background-color: #F7F2FA;&#10;                width: 12px;&#10;                border-radius: 6px;&#10;                margin: 2px;&#10;            }&#10;            QScrollBar::handle:vertical {&#10;                background-color: #CAC4D0;&#10;                border-radius: 6px;&#10;                min-height: 30px;&#10;            }&#10;            QScrollBar::handle:vertical:hover {&#10;                background-color: #79747E;&#10;            }&#10;            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {&#10;                border: none;&#10;                background: none;&#10;                height: 0px;&#10;            }&#10;        &quot;&quot;&quot;)&#10;&#10;        grid_widget = QWidget()&#10;        grid_widget.setStyleSheet(&quot;background-color: transparent;&quot;)&#10;        self.grid_layout = QGridLayout(grid_widget)&#10;        self.grid_layout.setSpacing(16)  # Material Design grid spacing&#10;        self.grid_layout.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft)&#10;        self.grid_layout.setContentsMargins(8, 8, 8, 8)&#10;        self.scroll_area.setWidget(grid_widget)&#10;        main_layout.addWidget(self.scroll_area)&#10;&#10;        self.update_apps()&#10;&#10;    def safe_close(self):&#10;        &quot;&quot;&quot;Material Design close transition&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;&#10;        if self._is_hidden_mode and self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;            QTimer.singleShot(200, self._complete_close)&#10;        else:&#10;            self._is_closing = True&#10;            self.fade_out()&#10;&#10;    def _complete_close(self):&#10;        &quot;&quot;&quot;Complete the Material Design close sequence&quot;&quot;&quot;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;        self._is_closing = True&#10;        self.close_requested.emit()&#10;&#10;    def fade_in(self, center_pos):&#10;        &quot;&quot;&quot;Material Design scale-in animation&quot;&quot;&quot;&#10;        print(f&quot;Material fade_in called with center_pos: {center_pos}&quot;)&#10;&#10;        self.anim_group.stop()&#10;&#10;        final_x = int(center_pos.x() - self.width() // 2)&#10;        final_y = int(center_pos.y() - self.height() // 2)&#10;&#10;        # Material Design scale factor&#10;        scale_factor = 0.8&#10;        start_width = int(self.width() * scale_factor)&#10;        start_height = int(self.height() * scale_factor)&#10;        start_x = int(center_pos.x() - start_width // 2)&#10;        start_y = int(center_pos.y() - start_height // 2)&#10;&#10;        self.setGeometry(start_x, start_y, start_width, start_height)&#10;        self.setWindowOpacity(0.0)&#10;        self.show()&#10;        self.raise_()&#10;&#10;        # Material Design animation curves&#10;        self.opacity_animation.setStartValue(0.0)&#10;        self.opacity_animation.setEndValue(1.0)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        start_rect = QRect(start_x, start_y, start_width, start_height)&#10;        final_rect = QRect(final_x, final_y, self.width(), self.height())&#10;        self.scale_animation.setStartValue(start_rect)&#10;        self.scale_animation.setEndValue(final_rect)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;        self.anim_group.start()&#10;&#10;    def fade_out(self):&#10;        &quot;&quot;&quot;Material Design scale-out animation&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;        self._is_closing = True&#10;&#10;        self.anim_group.stop()&#10;&#10;        current_rect = self.geometry()&#10;        center_x, center_y = current_rect.center().x(), current_rect.center().y()&#10;&#10;        scale_factor = 0.8&#10;        end_width = int(self.width() * scale_factor)&#10;        end_height = int(self.height() * scale_factor)&#10;        end_x = int(center_x - end_width // 2)&#10;        end_y = int(center_y - end_height // 2)&#10;&#10;        self.opacity_animation.setStartValue(1.0)&#10;        self.opacity_animation.setEndValue(0.0)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.InCubic)&#10;&#10;        end_rect = QRect(end_x, end_y, end_width, end_height)&#10;        self.scale_animation.setStartValue(current_rect)&#10;        self.scale_animation.setEndValue(end_rect)&#10;        self.scale_animation.setEasingCurve(QEasingCurve.Type.InCubic)&#10;&#10;        self.anim_group.start()&#10;&#10;    def hide_and_show_floating_icon(self):&#10;        &quot;&quot;&quot;Material Design transition to floating action button&quot;&quot;&quot;&#10;        if self._is_closing or self._is_transitioning:&#10;            return&#10;&#10;        print(&quot;Material Design transition to FAB&quot;)&#10;        self._is_transitioning = True&#10;        self._is_hidden_mode = True&#10;&#10;        main_window = self.parent()&#10;        while main_window and main_window.parent():&#10;            main_window = main_window.parent()&#10;        parent = main_window&#10;&#10;        # Material Design floating action button&#10;        self.floating_icon = FloatingFolderIcon(self.folder_ref.folder_name, parent)&#10;        self.position_floating_icon()&#10;        self.floating_icon.clicked_signal.connect(self.restore_from_floating_icon)&#10;&#10;        self.hide()&#10;        self.setWindowOpacity(0.0)&#10;&#10;        QTimer.singleShot(50, self.floating_icon.show_with_animation)&#10;        QTimer.singleShot(300, lambda: setattr(self, '_is_transitioning', False))&#10;&#10;        # Material Design scrim update&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            self.folder_ref.overlay.disable_overlay_close = True&#10;            self.folder_ref.overlay.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.05);&quot;)&#10;&#10;    def position_floating_icon(self):&#10;        &quot;&quot;&quot;Position FAB according to Material Design guidelines&quot;&quot;&quot;&#10;        if not self.floating_icon or not self.floating_icon.parent():&#10;            return&#10;&#10;        parent_rect = self.floating_icon.parent().rect()&#10;        margin = 24  # Material Design FAB margin&#10;&#10;        # x = margin&#10;        # y = parent_rect.height() - self.floating_icon.height() - margin&#10;        x = 10&#10;        y = 10&#10;&#10;        self.floating_icon.move(x, y)&#10;&#10;    def restore_from_floating_icon(self):&#10;        &quot;&quot;&quot;Material Design restoration from FAB&quot;&quot;&quot;&#10;        print(&quot;Material Design FAB clicked - restoring&quot;)&#10;&#10;        if self._is_transitioning:&#10;            return&#10;&#10;        self._is_transitioning = True&#10;        self._is_hidden_mode = False&#10;&#10;        if self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;&#10;        # Restore Material Design scrim&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            self.folder_ref.overlay.disable_overlay_close = False&#10;            self.folder_ref.overlay.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.32);&quot;)  # Material scrim&#10;            self.folder_ref.overlay.show()&#10;            self.folder_ref.overlay.raise_()&#10;&#10;        main_window = None&#10;        if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;            main_window = self.folder_ref.overlay.parent()&#10;&#10;        if not main_window:&#10;            main_window = self.floating_icon.parent() if self.floating_icon else None&#10;            while main_window and main_window.parent():&#10;                main_window = main_window.parent()&#10;&#10;        if main_window:&#10;            if hasattr(self.folder_ref, &quot;overlay&quot;) and self.folder_ref.overlay:&#10;                self.setParent(self.folder_ref.overlay)&#10;&#10;            center_pos = main_window.rect().center()&#10;            QTimer.singleShot(100, lambda: self.fade_in(center_pos))&#10;&#10;            if self._current_app_name:&#10;                QTimer.singleShot(400, self.show_close_app_button)&#10;&#10;        QTimer.singleShot(300, self._cleanup_floating_icon)&#10;        QTimer.singleShot(500, lambda: setattr(self, '_is_transitioning', False))&#10;&#10;    def _cleanup_floating_icon(self):&#10;        &quot;&quot;&quot;Clean up floating action button&quot;&quot;&quot;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;    def update_apps(self):&#10;        &quot;&quot;&quot;Update app grid with Material Design styling&quot;&quot;&quot;&#10;        while self.grid_layout.count():&#10;            item = self.grid_layout.takeAt(0)&#10;            if item and item.widget():&#10;                item.widget().setParent(None)&#10;                item.widget().deleteLater()&#10;&#10;        cols = 4&#10;        if hasattr(self.folder_ref, 'buttons'):&#10;            visible_buttons = [button for button in self.folder_ref.buttons if button.icon_label != self._current_app_name]&#10;            for i, button in enumerate(visible_buttons):&#10;                row, col = divmod(i, cols)&#10;                button_copy = MenuIcon(button.icon_label, button.icon_path, button.icon_text, button.callback)&#10;                button_copy.button_clicked.connect(self.on_app_clicked)&#10;                self.grid_layout.addWidget(button_copy, row, col)&#10;&#10;    def on_app_clicked(self, app_name):&#10;        &quot;&quot;&quot;Handle app selection with Material Design feedback&quot;&quot;&quot;&#10;        print(f&quot;Material Design app selected: {app_name}&quot;)&#10;        self._current_app_name = app_name&#10;        self.app_selected.emit(app_name)&#10;        self.show_close_app_button()&#10;        self.hide_and_show_floating_icon()&#10;&#10;    def show_close_app_button(self):&#10;        &quot;&quot;&quot;Material Design button reveal animation&quot;&quot;&quot;&#10;        if self.close_app_button and self._current_app_name:&#10;            self.close_app_button.setText(f&quot;BACK&quot;)&#10;            self.close_app_button.show()&#10;&#10;            # Material Design fade-in&#10;            self.close_app_button.setWindowOpacity(0.0)&#10;            button_animation = QPropertyAnimation(self.close_app_button, b&quot;windowOpacity&quot;)&#10;            button_animation.setDuration(200)&#10;            button_animation.setStartValue(0.0)&#10;            button_animation.setEndValue(1.0)&#10;            button_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;            button_animation.start()&#10;&#10;    def hide_close_app_button(self):&#10;        &quot;&quot;&quot;Hide close button with Material Design transition&quot;&quot;&quot;&#10;        if self.close_app_button:&#10;            self.close_app_button.hide()&#10;        self._current_app_name = None&#10;&#10;    def on_close_app_clicked(self):&#10;        &quot;&quot;&quot;Handle close app with Material Design interaction&quot;&quot;&quot;&#10;        print(f&quot;Material Design close app: {self._current_app_name}&quot;)&#10;        self.close_current_app_requested.emit()&#10;        self.hide_close_app_button()&#10;&#10;        # When back button is pressed, fully close the folder&#10;        if self._is_hidden_mode and self.floating_icon:&#10;            self.floating_icon.hide_with_animation()&#10;            QTimer.singleShot(200, self._complete_close)&#10;        else:&#10;            # Not in hidden mode, trigger normal close&#10;            self.close_requested.emit()&#10;&#10;    def set_app_running_state(self, app_name=None):&#10;        &quot;&quot;&quot;Update app state with Material Design consistency&quot;&quot;&quot;&#10;        if app_name:&#10;            self._current_app_name = app_name&#10;            self.show_close_app_button()&#10;        else:&#10;            self.hide_close_app_button()&#10;&#10;    def animation_finished(self):&#10;        &quot;&quot;&quot;Material Design animation completion handler&quot;&quot;&quot;&#10;        if self._is_closing:&#10;            QTimer.singleShot(0, self.safe_hide)&#10;&#10;    def safe_hide(self):&#10;        &quot;&quot;&quot;Safe hide with Material Design cleanup&quot;&quot;&quot;&#10;        if self._is_closing:&#10;            QTimer.singleShot(0, self.hide)&#10;            if self.floating_icon:&#10;                self.floating_icon.deleteLater()&#10;                self.floating_icon = None&#10;&#10;    def mousePressEvent(self, event):&#10;        event.accept()&#10;&#10;    def closeEvent(self, event):&#10;        &quot;&quot;&quot;Material Design close event handling&quot;&quot;&quot;&#10;        self._is_closing = True&#10;        self.anim_group.stop()&#10;&#10;        if self.floating_icon:&#10;            self.floating_icon.deleteLater()&#10;            self.floating_icon = None&#10;&#10;        while self.grid_layout.count():&#10;            item = self.grid_layout.takeAt(0)&#10;            if item and item.widget():&#10;                item.widget().setParent(None)&#10;                item.widget().deleteLater()&#10;        event.accept()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from PyQt6.QtWidgets import QApplication, QMainWindow, QPushButton&#10;&#10;    app = QApplication(sys.argv)&#10;&#10;    # Material Design application styling&#10;    app.setStyle('Fusion')&#10;    app.setStyleSheet(&quot;&quot;&quot;&#10;        QApplication {&#10;            font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;            background: #FFFBFE;&#10;        }&#10;    &quot;&quot;&quot;)&#10;&#10;    main_window = QMainWindow()&#10;    main_window.resize(900, 700)&#10;    main_window.setStyleSheet(&quot;&quot;&quot;&#10;        QMainWindow {&#10;            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,&#10;                stop:0 #FFFBFE,&#10;                stop:1 #F7F2FA);&#10;        }&#10;    &quot;&quot;&quot;)&#10;&#10;    folder_view = ExpandedFolderView(&#10;        folder_ref=type('Folder', (), {'folder_name': 'Material Apps', 'buttons': []}),&#10;        parent=main_window&#10;    )&#10;    folder_view.fade_in(main_window.rect().center())&#10;    main_window.setCentralWidget(folder_view)&#10;    main_window.show()&#10;&#10;    # Material Design test button&#10;    test_button = QPushButton(&quot;Test Material FAB&quot;, main_window)&#10;    test_button.setGeometry(10, 10, 200, 48)&#10;    test_button.setStyleSheet(&quot;&quot;&quot;&#10;        QPushButton {&#10;            background: #6750A4;&#10;            border: none;&#10;            border-radius: 24px;&#10;            color: white;&#10;            font-size: 14px;&#10;            font-weight: 500;&#10;            font-family: 'Roboto', 'Segoe UI', sans-serif;&#10;        }&#10;        QPushButton:hover {&#10;            background: #7965AF;&#10;        }&#10;    &quot;&quot;&quot;)&#10;    test_button.clicked.connect(folder_view.hide_and_show_floating_icon)&#10;    test_button.show()&#10;&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pl_gui/main_application/FolderOverlay.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pl_gui/main_application/FolderOverlay.py" />
              <option name="originalContent" value="from PyQt6.QtCore import pyqtSignal, Qt, QPropertyAnimation, QEasingCurve&#10;from PyQt6.QtWidgets import QWidget&#10;&#10;&#10;class FolderOverlay(QWidget):&#10;    &quot;&quot;&quot;Overlay widget that appears when folder is opened&quot;&quot;&quot;&#10;&#10;    close_requested = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.5);&quot;)&#10;        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)&#10;        self.disable_overlay_close = False&#10;        # Animation for fade in/out&#10;        self.opacity_animation = QPropertyAnimation(self, b&quot;windowOpacity&quot;)&#10;        self.opacity_animation.setDuration(300)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;    def fade_in(self):&#10;        &quot;&quot;&quot;Animate overlay appearance&quot;&quot;&quot;&#10;        self.setWindowOpacity(0.0)&#10;        self.show()&#10;        self.opacity_animation.setStartValue(0.0)&#10;        self.opacity_animation.setEndValue(1.0)&#10;        self.opacity_animation.start()&#10;&#10;    def fade_out(self):&#10;        &quot;&quot;&quot;Animate overlay disappearance&quot;&quot;&quot;&#10;        self.opacity_animation.setStartValue(1.0)&#10;        self.opacity_animation.setEndValue(0.0)&#10;        self.opacity_animation.finished.connect(self.hide)&#10;        self.opacity_animation.start()&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Close folder when clicking outside, unless disabled&quot;&quot;&quot;&#10;        if not self.disable_overlay_close:&#10;            parent = self.parent()&#10;            expanded_view = None&#10;            if hasattr(parent, 'current_app_folder') and hasattr(parent.current_app_folder, 'expanded_view'):&#10;                expanded_view = parent.current_app_folder.expanded_view&#10;            if expanded_view:&#10;                if expanded_view._current_app_name:&#10;                    # App is running - minimize expanded view (collapse to floating icon)&#10;                    expanded_view.close_from_outside()&#10;                    event.accept()&#10;                    return&#10;&#10;            # No app running - normal close&#10;            self.close_requested.emit()&#10;        super().mousePressEvent(event)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from PyQt6.QtWidgets import QApplication&#10;&#10;    app = QApplication(sys.argv)&#10;    overlay = FolderOverlay()&#10;    overlay.resize(800, 600)&#10;    overlay.fade_in()&#10;    overlay.show()&#10;    sys.exit(app.exec())" />
              <option name="updatedContent" value="from PyQt6.QtCore import pyqtSignal, Qt, QPropertyAnimation, QEasingCurve&#10;from PyQt6.QtWidgets import QWidget&#10;&#10;&#10;class FolderOverlay(QWidget):&#10;    &quot;&quot;&quot;Overlay widget that appears when folder is opened&quot;&quot;&quot;&#10;&#10;    close_requested = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setStyleSheet(&quot;background-color: rgba(0, 0, 0, 0.5);&quot;)&#10;        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)&#10;        self.disable_overlay_close = False&#10;        # Animation for fade in/out&#10;        self.opacity_animation = QPropertyAnimation(self, b&quot;windowOpacity&quot;)&#10;        self.opacity_animation.setDuration(300)&#10;        self.opacity_animation.setEasingCurve(QEasingCurve.Type.OutCubic)&#10;&#10;    def fade_in(self):&#10;        &quot;&quot;&quot;Animate overlay appearance&quot;&quot;&quot;&#10;        self.setWindowOpacity(0.0)&#10;        self.show()&#10;        self.opacity_animation.setStartValue(0.0)&#10;        self.opacity_animation.setEndValue(1.0)&#10;        self.opacity_animation.start()&#10;&#10;    def fade_out(self):&#10;        &quot;&quot;&quot;Animate overlay disappearance&quot;&quot;&quot;&#10;        self.opacity_animation.setStartValue(1.0)&#10;        self.opacity_animation.setEndValue(0.0)&#10;        self.opacity_animation.finished.connect(self.hide)&#10;        self.opacity_animation.start()&#10;&#10;    def mousePressEvent(self, event):&#10;        &quot;&quot;&quot;Close folder when clicking outside, unless disabled&quot;&quot;&quot;&#10;        if not self.disable_overlay_close:&#10;            parent = self.parent()&#10;            expanded_view = None&#10;            if hasattr(parent, 'current_app_folder') and hasattr(parent.current_app_folder, 'expanded_view'):&#10;                expanded_view = parent.current_app_folder.expanded_view&#10;            if expanded_view:&#10;                if expanded_view._current_app_name:&#10;                    # App is running - minimize expanded view (collapse to floating icon)&#10;                    expanded_view.close_from_outside()&#10;                    # Hide overlay so user can interact with the app&#10;                    self.hide()&#10;                    event.accept()&#10;                    return&#10;&#10;            # No app running - normal close&#10;            self.close_requested.emit()&#10;        super().mousePressEvent(event)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    import sys&#10;    from PyQt6.QtWidgets import QApplication&#10;&#10;    app = QApplication(sys.argv)&#10;    overlay = FolderOverlay()&#10;    overlay.resize(800, 600)&#10;    overlay.fade_in()&#10;    overlay.show()&#10;    sys.exit(app.exec())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>